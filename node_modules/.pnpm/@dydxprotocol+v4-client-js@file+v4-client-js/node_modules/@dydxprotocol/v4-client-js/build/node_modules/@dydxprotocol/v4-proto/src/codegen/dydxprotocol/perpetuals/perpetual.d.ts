/// <reference types="long" />
import * as _m0 from "protobufjs/minimal";
import { Long } from "../../helpers";
/** Perpetual represents a perpetual on the dYdX exchange. */
export interface Perpetual {
    /** PerpetualParams is the parameters of the perpetual. */
    params?: PerpetualParams;
    /**
     * The current index determined by the cumulative all-time
     * history of the funding mechanism. Starts at zero.
     */
    fundingIndex: Uint8Array;
}
/** Perpetual represents a perpetual on the dYdX exchange. */
export interface PerpetualSDKType {
    params?: PerpetualParamsSDKType;
    funding_index: Uint8Array;
}
/**
 * PerpetualParams represents the parameters of a perpetual on the dYdX
 * exchange.
 */
export interface PerpetualParams {
    /** Unique, sequentially-generated. */
    id: number;
    /** The name of the `Perpetual` (e.g. `BTC-USD`). */
    ticker: string;
    /**
     * The market associated with this `Perpetual`. It
     * acts as the oracle price for the purposes of calculating
     * collateral, margin requirements, and funding rates.
     */
    marketId: number;
    /**
     * The exponent for converting an atomic amount (`size = 1`)
     * to a full coin. For example, if `AtomicResolution = -8`
     * then a `PerpetualPosition` with `size = 1e8` is equivalent to
     * a position size of one full coin.
     */
    atomicResolution: number;
    /**
     * The default funding payment if there is no price premium. In
     * parts-per-million.
     */
    defaultFundingPpm: number;
    /** The liquidity_tier that this perpetual is associated with. */
    liquidityTier: number;
}
/**
 * PerpetualParams represents the parameters of a perpetual on the dYdX
 * exchange.
 */
export interface PerpetualParamsSDKType {
    id: number;
    ticker: string;
    market_id: number;
    atomic_resolution: number;
    default_funding_ppm: number;
    liquidity_tier: number;
}
/** MarketPremiums stores a list of premiums for a single perpetual market. */
export interface MarketPremiums {
    /** perpetual_id is the Id of the perpetual market. */
    perpetualId: number;
    /**
     * premiums is a list of premium values for a perpetual market. Since most
     * premiums are zeros under "stable" market conditions, only non-zero values
     * are stored in this list.
     */
    premiums: number[];
}
/** MarketPremiums stores a list of premiums for a single perpetual market. */
export interface MarketPremiumsSDKType {
    perpetual_id: number;
    premiums: number[];
}
/**
 * PremiumStore is a struct to store a perpetual premiums for all
 * perpetual markets. It stores a list of `MarketPremiums`, each of which
 * corresponds to a perpetual market and stores a list of non-zero premium
 * values for that market.
 * This struct can either be used to store `PremiumVotes` or
 * `PremiumSamples`.
 */
export interface PremiumStore {
    /**
     * all_market_premiums a list of `MarketPremiums`, each corresponding to
     * a perpetual market.
     */
    allMarketPremiums: MarketPremiums[];
    /**
     * number of rounds where premium values were added. This value indicates
     * the total number of premiums (zeros and non-zeros) for each
     * `MarketPremiums` struct. Note that in the edge case a perpetual market was
     * added in the middle of a epoch, we don't keep a seperate count for that
     * market. This means we treat this market as having zero premiums before it
     * was added.
     */
    numPremiums: number;
}
/**
 * PremiumStore is a struct to store a perpetual premiums for all
 * perpetual markets. It stores a list of `MarketPremiums`, each of which
 * corresponds to a perpetual market and stores a list of non-zero premium
 * values for that market.
 * This struct can either be used to store `PremiumVotes` or
 * `PremiumSamples`.
 */
export interface PremiumStoreSDKType {
    all_market_premiums: MarketPremiumsSDKType[];
    num_premiums: number;
}
/** LiquidityTier stores margin information. */
export interface LiquidityTier {
    /** Unique id. */
    id: number;
    /** The name of the tier purely for mnemonic purposes, e.g. "Gold". */
    name: string;
    /**
     * The margin fraction needed to open a position.
     * In parts-per-million.
     */
    initialMarginPpm: number;
    /**
     * The fraction of the initial-margin that the maintenance-margin is,
     * e.g. 50%. In parts-per-million.
     */
    maintenanceFractionPpm: number;
    /**
     * The maximum position size at which the margin requirements are
     * not increased over the default values. Above this position size,
     * the margin requirements increase at a rate of sqrt(size).
     *
     * Deprecated since v3.x.
     */
    /** @deprecated */
    basePositionNotional: Long;
    /**
     * The impact notional amount (in quote quantums) is used to determine impact
     * bid/ask prices and its recommended value is 500 USDC / initial margin
     * fraction.
     * - Impact bid price = average execution price for a market sell of the
     * impact notional value.
     * - Impact ask price = average execution price for a market buy of the
     * impact notional value.
     */
    impactNotional: Long;
}
/** LiquidityTier stores margin information. */
export interface LiquidityTierSDKType {
    id: number;
    name: string;
    initial_margin_ppm: number;
    maintenance_fraction_ppm: number;
    /** @deprecated */
    base_position_notional: Long;
    impact_notional: Long;
}
export declare const Perpetual: {
    encode(message: Perpetual, writer?: _m0.Writer): _m0.Writer;
    decode(input: Uint8Array | _m0.Reader, length?: number | undefined): Perpetual;
    fromPartial(object: {
        params?: {
            id?: number | undefined;
            ticker?: string | undefined;
            marketId?: number | undefined;
            atomicResolution?: number | undefined;
            defaultFundingPpm?: number | undefined;
            liquidityTier?: number | undefined;
        } | undefined;
        fundingIndex?: Uint8Array | undefined;
    }): Perpetual;
};
export declare const PerpetualParams: {
    encode(message: PerpetualParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: Uint8Array | _m0.Reader, length?: number | undefined): PerpetualParams;
    fromPartial(object: {
        id?: number | undefined;
        ticker?: string | undefined;
        marketId?: number | undefined;
        atomicResolution?: number | undefined;
        defaultFundingPpm?: number | undefined;
        liquidityTier?: number | undefined;
    }): PerpetualParams;
};
export declare const MarketPremiums: {
    encode(message: MarketPremiums, writer?: _m0.Writer): _m0.Writer;
    decode(input: Uint8Array | _m0.Reader, length?: number | undefined): MarketPremiums;
    fromPartial(object: {
        perpetualId?: number | undefined;
        premiums?: number[] | undefined;
    }): MarketPremiums;
};
export declare const PremiumStore: {
    encode(message: PremiumStore, writer?: _m0.Writer): _m0.Writer;
    decode(input: Uint8Array | _m0.Reader, length?: number | undefined): PremiumStore;
    fromPartial(object: {
        allMarketPremiums?: {
            perpetualId?: number | undefined;
            premiums?: number[] | undefined;
        }[] | undefined;
        numPremiums?: number | undefined;
    }): PremiumStore;
};
export declare const LiquidityTier: {
    encode(message: LiquidityTier, writer?: _m0.Writer): _m0.Writer;
    decode(input: Uint8Array | _m0.Reader, length?: number | undefined): LiquidityTier;
    fromPartial(object: {
        id?: number | undefined;
        name?: string | undefined;
        initialMarginPpm?: number | undefined;
        maintenanceFractionPpm?: number | undefined;
        basePositionNotional?: string | number | Long.Long | undefined;
        impactNotional?: string | number | Long.Long | undefined;
    }): LiquidityTier;
};
