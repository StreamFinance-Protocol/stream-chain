"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.teardown = exports.migrate = exports.reset = exports.clearSchema = exports.clearData = exports.createModelToJsonFunctions = void 0;
const base_1 = require("@dydxprotocol-indexer/base");
const config_1 = __importDefault(require("../config"));
const constants_1 = require("../constants");
const knex_1 = require("./knex");
const stores_helpers_1 = require("./stores-helpers");
const layer2Tables = [
    'perpetual_positions',
    'fills',
];
const layer1Tables = [
    'subaccounts',
    'markets',
    'orders',
    'perpetual_markets',
    'tendermint_events',
    'transactions',
    'blocks',
    'assets',
    'candles',
    'liquidity_tiers',
    'compliance_data',
];
/**
 * Returns the SQL statement that would convert the provided field and type to the type expected
 * by the model.
 *
 * Raises an error if an unknown conversion is requested.
 */
function getSqlConversionForDydxModelTypes(fieldName, type) {
    switch (type) {
        case 'integer':
            return `row_t."${fieldName}"::int`;
        case 'string':
            return `row_t."${fieldName}"::text`;
        case 'boolean':
            return `row_t."${fieldName}"::bool`;
        case 'hex-string':
            return `encode(row_t."${fieldName}", 'hex')`;
        case 'date-time':
            return `to_char(row_t."${fieldName}" at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"')`;
        default:
            throw new Error(`Unknown type conversion for ${type}`);
    }
}
/**
 * Defines a `dydx_to_jsonb` function for each of the models in SQL_TO_JSON_DEFINED_MODELS and
 * loads them in Postgres. This allows for plpgsql functions to invoke `dydx_to_jsonb` on the
 * associated models table row type and convert the record into a JSON representation which
 * conforms to the models schema allowing conversion to the model type via the models `fromJson`
 * method.
 */
async function createModelToJsonFunctions() {
    await Promise.all(constants_1.SQL_TO_JSON_DEFINED_MODELS.map(async (model) => {
        const sqlProperties = Object.entries(model.sqlToJsonConversions)
            .map(([key, value]) => `'${key}', ${getSqlConversionForDydxModelTypes(key, value)}`);
        const sqlFn = `CREATE OR REPLACE FUNCTION dydx_to_jsonb(row_t ${model.tableName}) RETURNS jsonb AS $$
BEGIN
    RETURN jsonb_build_object(
        ${sqlProperties.join(',\n        ')}
        );
    END;
$$ LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE;`;
        return (0, stores_helpers_1.rawQuery)(sqlFn, {}).catch((error) => {
            base_1.logger.error({
                at: 'dbHelpers#createModelToJsonFunctions',
                message: `Failed to create or replace function dydx_to_jsonb for model ${model.tableName}.`,
                error,
            });
            throw error;
        });
    }));
}
exports.createModelToJsonFunctions = createModelToJsonFunctions;
async function dropData() {
    await Promise.all(layer2Tables.map(async (table) => {
        return (0, knex_1.knexPrimary)(table).del();
    }));
    // need to use for... of to ensure tables are removed sequentially
    for (const table of layer1Tables) {
        await (0, knex_1.knexPrimary)(table).del();
    }
}
/**
 * Drops all functions named dydx_.* from the database.
 */
async function dropAllDydxFunctions() {
    await knex_1.knexPrimary.raw(`DO
$do$
DECLARE
   _sql text;
BEGIN
   SELECT INTO _sql
          string_agg(format('DROP %s %s;'
                          , CASE prokind
                              WHEN 'f' THEN 'FUNCTION'
                              WHEN 'a' THEN 'AGGREGATE'
                              WHEN 'p' THEN 'PROCEDURE'
                              WHEN 'w' THEN 'FUNCTION'  -- window function (rarely applicable)
                              -- ELSE NULL              -- not possible in pg 11
                            END
                          , oid::regprocedure)
                   , E'\\n')
   FROM   pg_proc
   WHERE  pronamespace = 'public'::regnamespace  -- schema name here!
   AND proname LIKE 'dydx_%';

   IF _sql IS NOT NULL THEN
      EXECUTE _sql;         -- uncomment payload once you are sure
   ELSE
      RAISE NOTICE 'No fuctions found in schema %', quote_ident('public');
   END IF;
END
$do$;`);
}
async function clearData() {
    for (const table of layer1Tables) {
        const tableExists = await knex_1.knexPrimary.schema.hasTable(table);
        if (tableExists) {
            await knex_1.knexPrimary.raw(`truncate table "${table}" cascade`);
        }
    }
    await Promise.all(layer2Tables.map(async (table) => {
        const tableExists = await knex_1.knexPrimary.schema.hasTable(table);
        if (tableExists) {
            return knex_1.knexPrimary.raw(`truncate table "${table}" cascade`);
        }
    }));
}
exports.clearData = clearData;
async function clearSchema() {
    await knex_1.knexPrimary.schema.raw('DROP SCHEMA public CASCADE');
    await knex_1.knexPrimary.schema.raw('CREATE SCHEMA public');
}
exports.clearSchema = clearSchema;
async function reset() {
    await dropData();
    await dropAllDydxFunctions();
    await rollback();
}
exports.reset = reset;
async function rollback() {
    await knex_1.knexPrimary.migrate.rollback({ loadExtensions: ['.js'] });
}
async function migrate() {
    return knex_1.knexPrimary.migrate.latest({ loadExtensions: ['.js'] });
}
exports.migrate = migrate;
async function teardown() {
    await dropAllDydxFunctions();
    await knex_1.knexPrimary.destroy();
    if (config_1.default.IS_USING_DB_READONLY) {
        await knex_1.knexReadReplica.getConnection().destroy();
    }
}
exports.teardown = teardown;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGItaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9oZWxwZXJzL2RiLWhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEscURBQW9EO0FBRXBELHVEQUErQjtBQUMvQiw0Q0FBMEQ7QUFDMUQsaUNBQXNEO0FBQ3RELHFEQUE0QztBQUU1QyxNQUFNLFlBQVksR0FBRztJQUNuQixxQkFBcUI7SUFDckIsT0FBTztDQUNSLENBQUM7QUFFRixNQUFNLFlBQVksR0FBRztJQUNuQixhQUFhO0lBQ2IsU0FBUztJQUNULFFBQVE7SUFDUixtQkFBbUI7SUFDbkIsbUJBQW1CO0lBQ25CLGNBQWM7SUFDZCxRQUFRO0lBQ1IsUUFBUTtJQUNSLFNBQVM7SUFDVCxpQkFBaUI7SUFDakIsaUJBQWlCO0NBQ2xCLENBQUM7QUFFRjs7Ozs7R0FLRztBQUNILFNBQVMsaUNBQWlDLENBQUMsU0FBaUIsRUFBRSxJQUFZO0lBQ3hFLFFBQVEsSUFBSSxFQUFFO1FBQ1osS0FBSyxTQUFTO1lBQ1osT0FBTyxVQUFVLFNBQVMsUUFBUSxDQUFDO1FBQ3JDLEtBQUssUUFBUTtZQUNYLE9BQU8sVUFBVSxTQUFTLFNBQVMsQ0FBQztRQUN0QyxLQUFLLFNBQVM7WUFDWixPQUFPLFVBQVUsU0FBUyxTQUFTLENBQUM7UUFDdEMsS0FBSyxZQUFZO1lBQ2YsT0FBTyxpQkFBaUIsU0FBUyxXQUFXLENBQUM7UUFDL0MsS0FBSyxXQUFXO1lBQ2QsT0FBTyxrQkFBa0IsU0FBUyx3REFBd0QsQ0FBQztRQUM3RjtZQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLElBQUksRUFBRSxDQUFDLENBQUM7S0FDMUQ7QUFDSCxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0ksS0FBSyxVQUFVLDBCQUEwQjtJQUM5QyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2Ysc0NBQTBCLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRTtR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