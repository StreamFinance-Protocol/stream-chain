import Big from 'big.js';
import { DateTime } from 'luxon';
import { CandleResolution, FundingIndexMap, MarketsMap, PerpetualMarketFromDatabase, PerpetualPositionFromDatabase, TransferFromDatabase, TransferType, UpdatedPerpetualPositionSubaccountKafkaObject } from '../types';
/**
 * Converts a parts-per-million value to the string representation of the number. 1 ppm, or
 * parts-per-million is equal to 10^-6 (0.000001).
 * @param ppm Parts-per-million value.
 * @returns String representation of the parts-per-million value as a floating point number.
 */
export declare function ppmToString(ppm: number): string;
/**
 * Calculates maintenance margin based on initial margin and maintenance fraction.
 * maintenance margin = initial margin * maintenance fraction
 * @param initialMarginPpm Initial margin in parts-per-million.
 * @param maintenanceFractionPpm Maintenance fraction in parts-per-million.
 * @returns Maintenance margin in parts-per-million.
 */
export declare function getMaintenanceMarginPpm(initialMarginPpm: number, maintenanceFractionPpm: number): number;
/**
 * Computes the unsettled funding for a position.
 *
 * To compute the net USDC balance for a subaccount, sum the result of this function for all
 * open perpetual positions, and add it to the latest USDC asset position for
 * this subaccount.
 *
 * When funding index is increasing, shorts get paid & unsettled funding for shorts should
 * be positive, vice versa for longs.
 * When funding index is decreasing, longs get paid & unsettled funding for longs should
 * be positive, vice versa for shorts.
 *
 * @param position
 * @param latestFundingIndex
 * @param lastUpdateFundingIndex
 */
export declare function getUnsettledFunding(position: PerpetualPositionFromDatabase, latestFundingIndexMap: FundingIndexMap, lastUpdateFundingIndexMap: FundingIndexMap): Big;
/**
 * Get unrealized pnl for a perpetual position. If the perpetual market is not found in the
 * markets map or the oracle price is not found in the market, return 0.
 *
 * @param position Perpetual position object from the database, or the updated
 * perpetual position subaccountKafkaObject.
 * @param perpetualMarketsMap Map of perpetual ids to perpetual market objects from the database.
 * @returns Unrealized pnl of the position.
 */
export declare function getUnrealizedPnl(position: PerpetualPositionFromDatabase | UpdatedPerpetualPositionSubaccountKafkaObject, perpetualMarket: PerpetualMarketFromDatabase, marketsMap: MarketsMap): string;
/**
 * Gets the transfer type for a subaccount.
 *
 * If sender/recipient are both subaccounts, then it is a transfer_in/transfer_out.
 * If sender/recipient are wallet addresses, then it is a deposit/withdrawal.
 *
 * @param transfer
 * @param subaccountId
 */
export declare function getTransferType(transfer: TransferFromDatabase, subaccountId: string): TransferType;
export declare function calculateNormalizedCandleStartTime(time: DateTime, resolution: CandleResolution): DateTime;
