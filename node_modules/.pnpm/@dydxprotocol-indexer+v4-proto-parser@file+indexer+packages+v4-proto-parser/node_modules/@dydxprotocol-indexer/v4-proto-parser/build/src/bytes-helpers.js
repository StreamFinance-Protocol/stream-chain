"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64ToBytes = exports.bytesToBase64 = exports.bigIntToBytes = exports.bytesToBigInt = void 0;
/**
 * Converts a byte array (representing an arbitrary-size signed integer) into a bigint.
 * @param u Array of bytes represented as a Uint8Array.
 */
function bytesToBigInt(u) {
    if (u.length <= 1) {
        return BigInt(0);
    }
    // eslint-disable-next-line no-bitwise
    const negated = (u[0] & 1) === 1;
    const hex = Buffer.from(u.slice(1)).toString('hex');
    const abs = BigInt(`0x${hex}`);
    return negated
        ? -abs
        : abs;
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Converts a bigint to a byte array.
 * @param b bigint value that must be translated.
 */
function bigIntToBytes(b) {
    // Special-case zero.
    if (b === BigInt(0)) {
        return Uint8Array.from([0x02]);
    }
    const negated = b < 0;
    const abs = negated ? -b : b;
    // Generate the hex string and have it be even-length (prepended with a zero if needed).
    const hex = abs.toString(16);
    const hexPadded = hex.length % 2 === 0
        ? hex
        : `0${hex}`;
    // Add the sign+version byte.
    const hexWithSign = `${negated ? '03' : '02'}${hexPadded}`;
    return Uint8Array.from(Buffer.from(hexWithSign, 'hex'));
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Converts a byte array (representing an arbitrary-size signed integer) into a base64 string.
 * This is useful for JSON encoding.
 * @param u Array of bytes represented as a Uint8Array.
 */
function bytesToBase64(u) {
    return Buffer.from(u).toString('base64');
}
exports.bytesToBase64 = bytesToBase64;
/**
 * Converts a base64 string into a byte array.
 * This is useful for JSON decoding.
 * @param u string value in base64.
 */
function base64ToBytes(s) {
    return Uint8Array.from(Buffer.from(s, 'base64'));
}
exports.base64ToBytes = base64ToBytes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnl0ZXMtaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ieXRlcy1oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7R0FHRztBQUNILFNBQWdCLGFBQWEsQ0FDM0IsQ0FBYTtJQUViLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbEI7SUFDRCxzQ0FBc0M7SUFDdEMsTUFBTSxPQUFPLEdBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLE1BQU0sR0FBRyxHQUFXLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1RCxNQUFNLEdBQUcsR0FBVyxNQUFNLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZDLE9BQU8sT0FBTztRQUNaLENBQUMsQ0FBQyxDQUFDLEdBQUc7UUFDTixDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ1YsQ0FBQztBQWJELHNDQWFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsYUFBYSxDQUMzQixDQUFTO0lBRVQscUJBQXFCO0lBQ3JCLElBQUksQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNuQixPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ2hDO0lBRUQsTUFBTSxPQUFPLEdBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMvQixNQUFNLEdBQUcsR0FBVyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFckMsd0ZBQXdGO0lBQ3hGLE1BQU0sR0FBRyxHQUFXLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDckMsTUFBTSxTQUFTLEdBQVcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEtBQUssQ0FBQztRQUM1QyxDQUFDLENBQUMsR0FBRztRQUNMLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBRWQsNkJBQTZCO0lBQzdCLE1BQU0sV0FBVyxHQUFXLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxTQUFTLEVBQUUsQ0FBQztJQUVuRSxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMxRCxDQUFDO0FBckJELHNDQXFCQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixhQUFhLENBQzNCLENBQWE7SUFFYixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFKRCxzQ0FJQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixhQUFhLENBQzNCLENBQVM7SUFFVCxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQ3BCLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUN6QixDQUFDO0FBQ0osQ0FBQztBQU5ELHNDQU1DIn0=