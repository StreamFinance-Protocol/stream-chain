import * as t from '@babel/types';
import { objectPattern } from '../../utils';
import { variableSlug } from '@osmonauts/utils';
export const rpcHookFuncArguments = () => {
  return [objectPattern([t.objectProperty(t.identifier('rpc'), t.identifier('rpc'), false, true)], t.tsTypeAnnotation(t.tsTypeLiteral([t.tsPropertySignature(t.identifier('rpc'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))))])))];
};
export const rpcHookClassArguments = () => {
  return [t.objectExpression([t.objectProperty(t.identifier('rpc'), t.identifier('rpc'), false, true)])];
};
export const rpcHookNewTmRequire = (imports, path, methodName) => {
  imports.push({
    as: variableSlug(path),
    path
  });
  return t.callExpression(t.memberExpression(t.identifier(variableSlug(path)), t.identifier(methodName)), [t.identifier('rpc')]);
};
export const rpcHookRecursiveObjectProps = (names, leaf) => {
  const [name, ...rest] = names;
  let baseComponent;

  if (names.length === 1) {
    baseComponent = leaf ? leaf : t.identifier(name);
  } else {
    baseComponent = rpcHookRecursiveObjectProps(rest, leaf);
  }

  return t.objectExpression([t.objectProperty(t.identifier(name), baseComponent)]);
};
export const rpcHookTmNestedImportObject = (imports, obj, methodName) => {
  if (typeof obj === 'string') {
    return rpcHookNewTmRequire(imports, obj, methodName);
  }

  const keys = Object.keys(obj);
  return t.objectExpression(keys.map(name => {
    return t.objectProperty(t.identifier(name), rpcHookTmNestedImportObject(imports, obj[name], methodName));
  }));
};
export const createScopedRpcHookFactory = (context, obj, identifier) => {
  context.addUtil('ProtobufRpcClient');
  const hookImports = [];
  const ast = t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator( // createRPCQueryHooks
  t.identifier(identifier), t.arrowFunctionExpression([objectPattern([t.objectProperty(t.identifier('rpc'), t.identifier('rpc'), false, true)], t.tsTypeAnnotation(t.tsTypeLiteral([t.tsPropertySignature(t.identifier('rpc'), t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.identifier('ProtobufRpcClient')), t.tsUndefinedKeyword()])))])))], t.blockStatement([t.returnStatement(rpcHookTmNestedImportObject(hookImports, obj, 'createRpcQueryHooks'))]), false))]));
  const imports = hookImports.map(hookport => {
    return {
      "type": "ImportDeclaration",
      "importKind": "value",
      "specifiers": [{
        "type": "ImportNamespaceSpecifier",
        "local": {
          "type": "Identifier",
          "name": hookport.as
        }
      }],
      "source": {
        "type": "StringLiteral",
        "value": hookport.path
      }
    };
  });
  return [...imports, ast];
};