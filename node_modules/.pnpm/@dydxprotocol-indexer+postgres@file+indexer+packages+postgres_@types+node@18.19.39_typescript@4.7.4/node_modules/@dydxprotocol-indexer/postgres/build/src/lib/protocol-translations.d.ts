import { IndexerOrder, IndexerOrder_Side, IndexerOrder_TimeInForce, IndexerOrder_ConditionType, ClobPairStatus } from '@dydxprotocol-indexer/v4-protos';
import Big from 'big.js';
import { IsoString, OrderSide, OrderType, PerpetualMarketFromDatabase, PerpetualMarketStatus, TimeInForce } from '../types';
/**
 * @param subticks - quote quantums/base quantums e.g. (1e-14 USDC/1e-10 BTC)
 * @returns - quote currency / base currency (human readable price)
 */
export declare function subticksToPrice(subticks: string, perpetualMarket: PerpetualMarketFromDatabase): string;
/**
 * @param price - quote currency / base currency (human readable price)
 * @returns - quote quantums/base quantums e.g. (1e-14 USDC/1e-10 BTC)
 */
export declare function priceToSubticks(price: string, perpetualMarket: PerpetualMarketFromDatabase): string;
/**
 * @param perpetualMarket
 * @returns - tick size for a given perpetual market. Tick size is the minimum price movement on
 * the market in quote human.
 */
export declare function getTickSize(perpetualMarket: PerpetualMarketFromDatabase): string;
/**
 * Given a funding index from the protocol, convert it to a human readable units such that when
 * multiplied by the position size in human-readable units of the base currency (e.g. 1 ETH, 1 BTC)
 * results in the funding payment in human-readable units of the quote currency (e.g. 1.2 USDC).
 * The funding index from the protocol is in parts-per-million, and of the units
 * quote-quantums / base quantums.
 * Formula for funding payment:
 * F_Q = funding payment in quote quantums
 * F_Q_H = funding payment in human-readable units of the quote currency
 * R_Q = atomic resolution of quote currency
 * P_B = position size in base quantums
 * P_B_H = position size in human-readable units of the base currency
 * R_B = atomic resolution of base currency
 * FI = funding index from protocol
 * FI_H = funding index in human-readable units, such that when multipled by the position size in
 * human-readable units of the base currency, returns the funding payment in human-readable units of
 * the quote currency.
 *
 * F_Q_H = F_Q * (10 ^ R_Q) -> formula to get funding payment in human-readable units
 * P_B_H = P_B * (10 ^ R_B) -> formula to get position size in human-readable units
 * F_Q = P_B * (FI / 10 ^ 6) -> formula to get funding payment from funding index and position size
 * F_Q_H = P_B_H * (FI_H) -> desired formula with funding index in human-readable units
 *
 * Note: in F_Q = P_B * (FI * 10 ^ 6), we divide by 10^6 as funding index from protocol is in
 * parts-per-million.
 * Solving for FI_H, we get
 * FI_H = F_Q_H / P_B_H
 * FI_H = (F_Q * 10 ^ R_Q) / (P_B * 10 ^ R_B)
 * FI_H = ((P_B * (FI / 10 ^ 6)) *  10 ^ R_Q) / (P_B * 10 ^ R_B)
 * FI_H = ((FI / 10 ^ 6) * 10 ^ R_Q) / (10 ^ R_B)
 * FI_H = (FI * 10 ^ -6 * 10 ^ R_Q) / (10 ^ R_B) -> formula for human-readable funding index using
 * resolutions of base and quote currency along with the funding-index from the protocol
 * @param fundingIndex
 * @param perpetualMarket
 */
export declare function fundingIndexToHumanFixedString(fundingIndex: string, perpetualMarket: PerpetualMarketFromDatabase): string;
/**
 * Given a funding value in parts-per-million, convert it to a funding index in human-readable
 * units. This formula requires dividing ppm by 1^6 and also dividing by 8 as funding is returned
 * in 8 hour and we store funding rate in 1 hour increments.
 */
export declare function funding8HourValuePpmTo1HourRate(fundingValuePpm: number): string;
/**
 * Returns the step size for the given perpetual market.
 * Step size is the smallest factor allowed for order amounts on the market in human.
 * @param perpetualMarket
 * @returns
 */
export declare function getStepSize(perpetualMarket: PerpetualMarketFromDatabase): string;
export declare function quantumsToHumanFixedString(baseQuantums: string, atomicResolution: number): string;
/**
 * Returns the absolute human-readable size in string form, from the serialized
 * quantums buffer received from the protocol. This is a temporary function until
 * DEC-1597 (deprecate `isLong`) is completed.
 * @param serializedQuantums The serialized quantums buffer from the protocol
 * @param atomicResolution atomic resolution of the market
 * @returns absolute human-readable size
 */
export declare function serializedQuantumsToAbsHumanFixedString(serializedQuantums: Uint8Array, atomicResolution: number): string;
/**
 * @param quantums - the smallest increment of position size, and is determined by atomicResolution.
 * For example, an atomicResolution of 8 means the smallest increment of position size is 1e-8.
 * @returns - human readable position size
 */
export declare function quantumsToHuman(quantums: string, atomicResolution: number): Big;
export declare function humanToQuantums(human: string, atomicResolution: number): Big;
/**
 * Converts a price from the `Price` module in the V4 protocol to a human readable price.
 * @param protocolPrice Price value from the `Price` module.
 * @param exponent Exponent for the price from the `Price` module.
 * @returns Human readable price as a string.
 */
export declare function protocolPriceToHuman(protocolPrice: string, exponent: number): string;
/**
 * Converts the `Order_Side` enum from the protobuf to the `OrderSide` enum in postgres
 * @param protocolOrderSide `IndexerOrder_Side` enum from protobuf
 * @returns `OrderSide` corresponding to the `Order_Side` passed in
 */
export declare function protocolOrderSideToOrderSide(protocolOrderSide: IndexerOrder_Side): OrderSide;
/**
 * Converts the TimeInForce field from an IndexerOrder proto to a TimeInForce enum in the Indexer.
 * Special cased:
 * - UNSPECIFIED -> GTT
 * Throw an error if the input TimeInForce enum is not in the known enum values for TimeInForce.
 * @param protocolOrderTIF
 * @returns
 */
export declare function protocolOrderTIFToTIF(protocolOrderTIF: IndexerOrder_TimeInForce): TimeInForce;
/**
 * Converts TimeInForce enum in the Indexer to the TimeInForce field from an IndexerOrder proto.
 * GTT -> UNSPECIFIED.
 * Throw an error if the input TimeInForce enum is not in the known enum values for TimeInForce.
 * @param timeInForce
 */
export declare function tifToProtocolOrderTIF(timeInForce: TimeInForce): IndexerOrder_TimeInForce;
export declare function getGoodTilBlock(order: IndexerOrder): number | undefined;
export declare function getGoodTilBlockTime(order: IndexerOrder): IsoString | undefined;
/**
 * Converts ConditionType enum from an IndexerOrder proto to an OrderType in the Indexer.
 * Special cased:
 * - UNSPECIFIED -> LIMIT
 * Throw an error if the input ConditionType is not in the known enum values for ConditionType.
 * @param protocolConditionType
 * @returns
 */
export declare function protocolConditionTypeToOrderType(protocolConditionType: IndexerOrder_ConditionType): OrderType;
/**
 * Converts OrderType enum to protocol ConditionType.
 * Special cased:
 * - all unused types (not LIMIT / STOP-LIMIT/MARKET / TAKE-PROFIT (MARKET)) default to unspecified
 * - STOP_LIMIT and STOP_MARKET map to STOP_LOSS
 * - TAKE_PROFIT and TAKE_PROFIT_MARKET map to TAKE_PROFIT
 * @param orderType
 * @returns
 */
export declare function orderTypeToProtocolConditionType(orderType: OrderType): IndexerOrder_ConditionType;
export declare function clobStatusToMarketStatus(clobPairStatus: ClobPairStatus): PerpetualMarketStatus;
