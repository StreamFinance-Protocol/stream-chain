import { CandleResolution } from './candle-types';
import { FillType, Liquidity } from './fill-types';
import { OrderSide, OrderStatus, OrderType } from './order-types';
import { PerpetualMarketStatus, PerpetualMarketType } from './perpetual-market-types';
import { PerpetualPositionStatus } from './perpetual-position-types';
import { PositionSide } from './position-types';
import { TradeType } from './trade-types';
import { TransferType } from './transfer-types';
import { IsoString } from './utility-types';
/**
 * All types that will be stringified into the contents field of a websocket message.
 * Any changes to this file should also update the corresponding websocket message version in
 * packages/kafka/src/constants.ts.
 */
export interface OrderbookMessageContents {
    bids?: PriceLevel[];
    asks?: PriceLevel[];
}
export declare type PriceLevel = [string, string];
export interface SubaccountMessageContents {
    perpetualPositions?: PerpetualPositionSubaccountMessageContents[];
    assetPositions?: AssetPositionSubaccountMessageContents[];
    orders?: OrderSubaccountMessageContents[];
    fills?: FillSubaccountMessageContents[];
    transfers?: TransferSubaccountMessageContents;
}
export interface PerpetualPositionSubaccountMessageContents {
    address: string;
    subaccountNumber: number;
    positionId: string;
    market: string;
    side: PositionSide;
    status: PerpetualPositionStatus;
    size: string;
    maxSize: string;
    netFunding: string;
    entryPrice: string;
    exitPrice?: string;
    sumOpen: string;
    sumClose: string;
    realizedPnl?: string;
    unrealizedPnl?: string;
}
export interface AssetPositionSubaccountMessageContents {
    address: string;
    subaccountNumber: number;
    positionId: string;
    assetId: string;
    symbol: string;
    side: PositionSide;
    size: string;
}
export declare enum APITimeInForce {
    GTT = "GTT",
    FOK = "FOK",
    IOC = "IOC"
}
export declare enum BestEffortOpenedStatus {
    BEST_EFFORT_OPENED = "BEST_EFFORT_OPENED"
}
export declare type APIOrderStatus = OrderStatus | BestEffortOpenedStatus;
export declare const APIOrderStatusEnum: {
    BEST_EFFORT_OPENED: BestEffortOpenedStatus.BEST_EFFORT_OPENED;
    OPEN: OrderStatus.OPEN;
    FILLED: OrderStatus.FILLED;
    CANCELED: OrderStatus.CANCELED;
    BEST_EFFORT_CANCELED: OrderStatus.BEST_EFFORT_CANCELED;
    UNTRIGGERED: OrderStatus.UNTRIGGERED;
};
export interface OrderSubaccountMessageContents {
    id: string;
    subaccountId: string;
    clientId: string;
    clobPairId: string;
    side: OrderSide;
    size: string;
    ticker: string;
    price: string;
    type: OrderType;
    timeInForce: APITimeInForce;
    postOnly: boolean;
    reduceOnly: boolean;
    status: APIOrderStatus;
    orderFlags: string;
    totalFilled?: string;
    totalOptimisticFilled?: string;
    goodTilBlock?: string;
    goodTilBlockTime?: string;
    triggerPrice?: string;
    updatedAt?: IsoString;
    updatedAtHeight?: string;
    removalReason?: string;
    createdAtHeight?: string;
    clientMetadata: string;
}
export interface FillSubaccountMessageContents {
    id: string;
    subaccountId: string;
    side: OrderSide;
    liquidity: Liquidity;
    type: FillType;
    clobPairId: string;
    size: string;
    price: string;
    quoteAmount: string;
    eventId: string;
    transactionHash: string;
    createdAt: IsoString;
    createdAtHeight: string;
    orderId?: string;
    ticker: string;
    clientMetadata?: string;
}
export interface TransferSubaccountMessageContents {
    sender: {
        address: string;
        subaccountNumber?: number;
    };
    recipient: {
        address: string;
        subaccountNumber?: number;
    };
    symbol: string;
    size: string;
    type: TransferType;
    transactionHash: string;
    createdAt: IsoString;
    createdAtHeight: string;
}
export interface TradeMessageContents {
    trades: TradeContent[];
}
export interface TradeContent {
    id: string;
    size: string;
    price: string;
    side: string;
    createdAt: IsoString;
    type: TradeType;
}
export interface MarketMessageContents {
    trading?: TradingMarketMessageContents;
    oraclePrices?: OraclePriceMarketMessageContentsMapping;
}
export declare type TradingMarketMessageContents = {
    [ticker: string]: TradingPerpetualMarketMessage;
};
export interface TradingPerpetualMarketMessage {
    id?: string;
    clobPairId?: string;
    ticker?: string;
    marketId?: number;
    status?: PerpetualMarketStatus;
    initialMarginFraction?: string;
    maintenanceMarginFraction?: string;
    openInterest?: string;
    quantumConversionExponent?: number;
    atomicResolution?: number;
    subticksPerTick?: number;
    stepBaseQuantums?: number;
    marketType?: PerpetualMarketType;
    priceChange24H?: string;
    volume24H?: string;
    trades24H?: number;
    nextFundingRate?: string;
}
export declare type OraclePriceMarketMessageContentsMapping = {
    [ticker: string]: OraclePriceMarket;
};
export interface OraclePriceMarket {
    oraclePrice: string;
    effectiveAt: IsoString;
    effectiveAtHeight: string;
    marketId: number;
}
export interface CandleMessageContents {
    resolution: CandleResolution;
    startedAt: IsoString;
    ticker: string;
    low: string;
    high: string;
    open: string;
    close: string;
    baseTokenVolume: string;
    trades: number;
    usdVolume: string;
    startingOpenInterest: string;
}
