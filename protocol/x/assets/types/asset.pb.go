// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/assets/asset.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Asset defines a single exchangable asset.
type Asset struct {
	// Unique, sequentially-generated.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The human readable symbol of the `Asset` (e.g. `TDAI`, `ATOM`).
	// Must be uppercase, unique and correspond to the canonical symbol of the
	// full coin.
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// The name of base denomination unit of the `Asset` (e.g. `uatom`,
	// 'ibc/xxxxx'). Must be unique and match the `denom` used in the `sdk.Coin`
	// type in the `x/bank` module.
	Denom string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty"`
	// The exponent of converting one unit of `denom` to a full coin.
	// For example, `name=USDC, denom=uusdc, denom_exponent=-6` defines that
	// `1 uusdc = 10^(-6) USDC`. Note that `uusdc` refers to a `Coin` type in
	// `x/bank`, where the prefix `u` means `micro` by convetion. `uusdc` is
	// a different concept from a "quantum" defined by `atomic_resolution` below.
	// To convert from an amount of `denom` to quantums:
	// `quantums = denom_amount * 10^(denom_exponent - atomic_resolution)`
	DenomExponent int32 `protobuf:"zigzag32,4,opt,name=denom_exponent,json=denomExponent,proto3" json:"denom_exponent,omitempty"`
	// `true` if this `Asset` has a valid `MarketId` value.
	HasMarket bool `protobuf:"varint,5,opt,name=has_market,json=hasMarket,proto3" json:"has_market,omitempty"`
	// The `Id` of the `Market` associated with this `Asset`. It acts as the
	// oracle price for the purposes of calculating collateral
	// and margin requirements.
	MarketId uint32 `protobuf:"varint,6,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The exponent for converting an atomic amount (1 'quantum')
	// to a full coin. For example, if `atomic_resolution = -8`
	// then an `asset_position` with `base_quantums = 1e8` is equivalent to
	// a position size of one full coin.
	AtomicResolution int32 `protobuf:"zigzag32,7,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// The current yield index is determined by the cumulative
	// all-time history of the yield mechanism for assets.
	// Starts at 0. This string should always be converted big.Rat.
	AssetYieldIndex string `protobuf:"bytes,8,opt,name=asset_yield_index,json=assetYieldIndex,proto3" json:"asset_yield_index,omitempty"`
	// The max slippage in ppm for the asset.
	MaxSlippagePpm uint32 `protobuf:"varint,9,opt,name=max_slippage_ppm,json=maxSlippagePpm,proto3" json:"max_slippage_ppm,omitempty"`
}

func (m *Asset) Reset()         { *m = Asset{} }
func (m *Asset) String() string { return proto.CompactTextString(m) }
func (*Asset) ProtoMessage()    {}
func (*Asset) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0b73b5c910a62b5, []int{0}
}
func (m *Asset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Asset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Asset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Asset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Asset.Merge(m, src)
}
func (m *Asset) XXX_Size() int {
	return m.Size()
}
func (m *Asset) XXX_DiscardUnknown() {
	xxx_messageInfo_Asset.DiscardUnknown(m)
}

var xxx_messageInfo_Asset proto.InternalMessageInfo

func (m *Asset) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Asset) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Asset) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *Asset) GetDenomExponent() int32 {
	if m != nil {
		return m.DenomExponent
	}
	return 0
}

func (m *Asset) GetHasMarket() bool {
	if m != nil {
		return m.HasMarket
	}
	return false
}

func (m *Asset) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *Asset) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *Asset) GetAssetYieldIndex() string {
	if m != nil {
		return m.AssetYieldIndex
	}
	return ""
}

func (m *Asset) GetMaxSlippagePpm() uint32 {
	if m != nil {
		return m.MaxSlippagePpm
	}
	return 0
}

func init() {
	proto.RegisterType((*Asset)(nil), "dydxprotocol.assets.Asset")
}

func init() { proto.RegisterFile("dydxprotocol/assets/asset.proto", fileDescriptor_d0b73b5c910a62b5) }

var fileDescriptor_d0b73b5c910a62b5 = []byte{
	// 348 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0xd1, 0x4d, 0x6a, 0xe3, 0x30,
	0x14, 0x07, 0xf0, 0xc8, 0x33, 0xc9, 0xc4, 0x82, 0x64, 0x12, 0xcd, 0x30, 0x08, 0x86, 0xba, 0xa6,
	0x50, 0x30, 0x2d, 0x49, 0x16, 0x3d, 0x41, 0x0b, 0x0d, 0x64, 0x51, 0x08, 0xce, 0xaa, 0xdd, 0xa8,
	0x8a, 0x25, 0x62, 0x51, 0xeb, 0x03, 0x4b, 0x01, 0xfb, 0x16, 0xbd, 0x47, 0x2f, 0xd2, 0x65, 0x96,
	0x5d, 0x96, 0xe4, 0x22, 0x25, 0x72, 0x12, 0xba, 0xb2, 0xde, 0xef, 0xff, 0xe0, 0x3d, 0xf3, 0xe0,
	0x39, 0xab, 0x59, 0x65, 0x4a, 0xed, 0x74, 0xa6, 0x8b, 0x09, 0xb5, 0x96, 0x3b, 0xdb, 0x7c, 0xc6,
	0x5e, 0xd1, 0x9f, 0xef, 0x0d, 0xe3, 0xa6, 0xe1, 0xe2, 0x2d, 0x80, 0xed, 0xdb, 0xfd, 0x13, 0xf5,
	0x61, 0x20, 0x18, 0x06, 0x31, 0x48, 0x7a, 0x69, 0x20, 0x18, 0xfa, 0x07, 0x3b, 0xb6, 0x96, 0x4b,
	0x5d, 0xe0, 0x20, 0x06, 0x49, 0x98, 0x1e, 0x2a, 0xf4, 0x17, 0xb6, 0x19, 0x57, 0x5a, 0xe2, 0x1f,
	0x9e, 0x9b, 0x02, 0x5d, 0xc2, 0xbe, 0x7f, 0x10, 0x5e, 0x19, 0xad, 0xb8, 0x72, 0xf8, 0x67, 0x0c,
	0x92, 0x61, 0xda, 0xf3, 0x7a, 0x7f, 0x40, 0x74, 0x06, 0x61, 0x4e, 0x2d, 0x91, 0xb4, 0x7c, 0xe1,
	0x0e, 0xb7, 0x63, 0x90, 0x74, 0xd3, 0x30, 0xa7, 0xf6, 0xc1, 0x03, 0xfa, 0x0f, 0xc3, 0x26, 0x22,
	0x82, 0xe1, 0x8e, 0x5f, 0xa5, 0xdb, 0xc0, 0x8c, 0xa1, 0x6b, 0x38, 0xa4, 0x4e, 0x4b, 0x91, 0x91,
	0x92, 0x5b, 0x5d, 0xac, 0x9d, 0xd0, 0x0a, 0xff, 0xf2, 0x53, 0x06, 0x4d, 0x90, 0x9e, 0x1c, 0x5d,
	0xc1, 0xa1, 0xff, 0x43, 0x52, 0x0b, 0x5e, 0x30, 0x22, 0x14, 0xe3, 0x15, 0xee, 0xfa, 0x8d, 0x7f,
	0xfb, 0xe0, 0x71, 0xef, 0xb3, 0x3d, 0xa3, 0x04, 0x0e, 0x24, 0xad, 0x88, 0x2d, 0x84, 0x31, 0x74,
	0xc5, 0x89, 0x31, 0x12, 0x87, 0x7e, 0x78, 0x5f, 0xd2, 0x6a, 0x71, 0xe0, 0xb9, 0x91, 0x77, 0xcf,
	0xef, 0xdb, 0x08, 0x6c, 0xb6, 0x11, 0xf8, 0xdc, 0x46, 0xe0, 0x75, 0x17, 0xb5, 0x36, 0xbb, 0xa8,
	0xf5, 0xb1, 0x8b, 0x5a, 0x4f, 0xd3, 0x95, 0x70, 0xf9, 0x7a, 0x39, 0xce, 0xb4, 0x9c, 0x2c, 0x5c,
	0xc9, 0xa9, 0x9c, 0x0a, 0x45, 0x55, 0xc6, 0x47, 0xf3, 0xe3, 0x49, 0xac, 0xe7, 0x51, 0x96, 0x53,
	0xa1, 0x26, 0xa7, 0x43, 0x55, 0xc7, 0x53, 0xb9, 0xda, 0x70, 0xbb, 0xec, 0xf8, 0xe0, 0xe6, 0x2b,
	0x00, 0x00, 0xff, 0xff, 0x8c, 0x87, 0x78, 0xe8, 0xce, 0x01, 0x00, 0x00,
}

func (m *Asset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Asset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSlippagePpm != 0 {
		i = encodeVarintAsset(dAtA, i, uint64(m.MaxSlippagePpm))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AssetYieldIndex) > 0 {
		i -= len(m.AssetYieldIndex)
		copy(dAtA[i:], m.AssetYieldIndex)
		i = encodeVarintAsset(dAtA, i, uint64(len(m.AssetYieldIndex)))
		i--
		dAtA[i] = 0x42
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintAsset(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.MarketId != 0 {
		i = encodeVarintAsset(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x30
	}
	if m.HasMarket {
		i--
		if m.HasMarket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DenomExponent != 0 {
		i = encodeVarintAsset(dAtA, i, uint64((uint32(m.DenomExponent)<<1)^uint32((m.DenomExponent>>31))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintAsset(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintAsset(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintAsset(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAsset(dAtA []byte, offset int, v uint64) int {
	offset -= sovAsset(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Asset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAsset(uint64(m.Id))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovAsset(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovAsset(uint64(l))
	}
	if m.DenomExponent != 0 {
		n += 1 + sozAsset(uint64(m.DenomExponent))
	}
	if m.HasMarket {
		n += 2
	}
	if m.MarketId != 0 {
		n += 1 + sovAsset(uint64(m.MarketId))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozAsset(uint64(m.AtomicResolution))
	}
	l = len(m.AssetYieldIndex)
	if l > 0 {
		n += 1 + l + sovAsset(uint64(l))
	}
	if m.MaxSlippagePpm != 0 {
		n += 1 + sovAsset(uint64(m.MaxSlippagePpm))
	}
	return n
}

func sovAsset(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAsset(x uint64) (n int) {
	return sovAsset(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Asset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomExponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DenomExponent = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMarket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMarket = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetYieldIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsset
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsset
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetYieldIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSlippagePpm", wireType)
			}
			m.MaxSlippagePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSlippagePpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAsset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAsset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAsset(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAsset
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAsset
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAsset
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAsset
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAsset        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAsset          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAsset = fmt.Errorf("proto: unexpected end of group")
)
