"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plugin = void 0;

var _imports = require("../imports");

var _ast = require("@osmonauts/ast");

var _protoParser = require("@osmonauts/proto-parser");

var _parse = require("../parse");

var plugin = function plugin(builder, bundler) {
  var clients = bundler.contexts.map(function (c) {
    var enabled = c.proto.pluginValue('rpcClients.enabled');
    if (!enabled) return;
    var inline = c.proto.pluginValue('rpcClients.inline');
    if (inline) return;
    if (c.proto.isExcluded()) return;
    var ctx = bundler.getFreshContext(c); // get mutations, services

    (0, _parse.parse)(ctx);
    var proto = (0, _protoParser.getNestedProto)(c.ref.traversed); //// Anything except Msg Service OK...

    var allowedRpcServices = builder.options.rpcClients.enabledServices.filter(function (a) {
      return a !== 'Msg';
    });
    var found = allowedRpcServices.some(function (svc) {
      var _proto$svc;

      return (proto === null || proto === void 0 ? void 0 : proto[svc]) && ((_proto$svc = proto[svc]) === null || _proto$svc === void 0 ? void 0 : _proto$svc.type) === 'Service';
    });

    if (!found) {
      return;
    } ///


    var name, getImportsFrom;
    allowedRpcServices.forEach(function (svcKey) {
      if (proto[svcKey]) {
        if (svcKey === 'Query') {
          getImportsFrom = ctx.queries;
        } else {
          getImportsFrom = ctx.services;
        }

        name = svcKey;
      }
    });
    var localname = bundler.getLocalFilename(c.ref, "rpc.".concat(name));
    var filename = bundler.getFilename(localname);
    var asts = [];
    allowedRpcServices.forEach(function (svcKey) {
      if (proto[svcKey]) {
        var svc = proto[svcKey];
        asts.push((0, _ast.createRpcClientInterface)(ctx.generic, svc));
        asts.push((0, _ast.createRpcClientClass)(ctx.generic, svc));

        if (c.proto.pluginValue('rpcClients.extensions')) {
          asts.push((0, _ast.createRpcQueryExtension)(ctx.generic, svc));
        } // react query
        // TODO use the imports and make separate files


        if (c.proto.pluginValue('reactQuery.enabled')) {
          [].push.apply(asts, (0, _ast.createRpcQueryHookInterfaces)(ctx.generic, svc));
          [].push.apply(asts, (0, _ast.createRpcQueryHookClientMap)(ctx.generic, svc));
          asts.push((0, _ast.createRpcQueryHooks)(ctx.generic, proto[svcKey]));
        }
      }
    });

    if (!asts.length) {
      return;
    }

    var serviceImports = (0, _imports.getDepsFromQueries)(getImportsFrom, localname); // TODO we do NOT need all imports...

    var imports = (0, _imports.buildAllImports)(ctx, serviceImports, localname);
    var prog = [].concat(imports).concat(ctx.body).concat(asts);
    bundler.writeAst(prog, filename);
    bundler.addToBundle(c, localname);
    return {
      "package": c.ref.proto["package"],
      localname: localname,
      filename: filename
    };
  }).filter(Boolean);
  bundler.addRPCQueryClients(clients);
};

exports.plugin = plugin;