// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/indexer/protocol/v1/subaccount.proto

package types

import (
	fmt "fmt"
	github_com_StreamFinance_Protocol_stream_chain_protocol_dtypes "github.com/StreamFinance-Protocol/stream-chain/protocol/dtypes"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IndexerSubaccountId defines a unique identifier for a Subaccount.
type IndexerSubaccountId struct {
	// The address of the wallet that owns this subaccount.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// < 128 Since 128 should be enough to start and it fits within
	// 1 Byte (1 Bit needed to indicate that the first byte is the last).
	Number uint32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *IndexerSubaccountId) Reset()         { *m = IndexerSubaccountId{} }
func (m *IndexerSubaccountId) String() string { return proto.CompactTextString(m) }
func (*IndexerSubaccountId) ProtoMessage()    {}
func (*IndexerSubaccountId) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c5845963309ad8f, []int{0}
}
func (m *IndexerSubaccountId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexerSubaccountId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexerSubaccountId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexerSubaccountId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexerSubaccountId.Merge(m, src)
}
func (m *IndexerSubaccountId) XXX_Size() int {
	return m.Size()
}
func (m *IndexerSubaccountId) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexerSubaccountId.DiscardUnknown(m)
}

var xxx_messageInfo_IndexerSubaccountId proto.InternalMessageInfo

func (m *IndexerSubaccountId) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *IndexerSubaccountId) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// IndexerPerpetualPosition are an account’s positions of a `Perpetual`.
// Therefore they hold any information needed to trade perpetuals.
type IndexerPerpetualPosition struct {
	// The `Id` of the `Perpetual`.
	PerpetualId uint32 `protobuf:"varint,1,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// The size of the position in base quantums.
	Quantums github_com_StreamFinance_Protocol_stream_chain_protocol_dtypes.SerializableInt `protobuf:"bytes,2,opt,name=quantums,proto3,customtype=github.com/StreamFinance-Protocol/stream-chain/protocol/dtypes.SerializableInt" json:"quantums"`
	// The funding_index of the `Perpetual` the last time this position was
	// settled.
	FundingIndex github_com_StreamFinance_Protocol_stream_chain_protocol_dtypes.SerializableInt `protobuf:"bytes,3,opt,name=funding_index,json=fundingIndex,proto3,customtype=github.com/StreamFinance-Protocol/stream-chain/protocol/dtypes.SerializableInt" json:"funding_index"`
	// Amount of funding payment (in quote quantums).
	// Note: 1. this field is not cumulative.
	// 2. a positive value means funding payment was paid out and
	// a negative value means funding payment was received.
	FundingPayment github_com_StreamFinance_Protocol_stream_chain_protocol_dtypes.SerializableInt `protobuf:"bytes,4,opt,name=funding_payment,json=fundingPayment,proto3,customtype=github.com/StreamFinance-Protocol/stream-chain/protocol/dtypes.SerializableInt" json:"funding_payment"`
}

func (m *IndexerPerpetualPosition) Reset()         { *m = IndexerPerpetualPosition{} }
func (m *IndexerPerpetualPosition) String() string { return proto.CompactTextString(m) }
func (*IndexerPerpetualPosition) ProtoMessage()    {}
func (*IndexerPerpetualPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c5845963309ad8f, []int{1}
}
func (m *IndexerPerpetualPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexerPerpetualPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexerPerpetualPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexerPerpetualPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexerPerpetualPosition.Merge(m, src)
}
func (m *IndexerPerpetualPosition) XXX_Size() int {
	return m.Size()
}
func (m *IndexerPerpetualPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexerPerpetualPosition.DiscardUnknown(m)
}

var xxx_messageInfo_IndexerPerpetualPosition proto.InternalMessageInfo

func (m *IndexerPerpetualPosition) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

// IndexerAssetPosition define an account’s positions of an `Asset`.
// Therefore they hold any information needed to trade on Spot and Margin.
type IndexerAssetPosition struct {
	// The `Id` of the `Asset`.
	AssetId uint32 `protobuf:"varint,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The absolute size of the position in base quantums.
	Quantums github_com_StreamFinance_Protocol_stream_chain_protocol_dtypes.SerializableInt `protobuf:"bytes,2,opt,name=quantums,proto3,customtype=github.com/StreamFinance-Protocol/stream-chain/protocol/dtypes.SerializableInt" json:"quantums"`
	// The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last
	// time this position was settled
	// TODO(DEC-582): pending margin trading being added.
	Index uint64 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *IndexerAssetPosition) Reset()         { *m = IndexerAssetPosition{} }
func (m *IndexerAssetPosition) String() string { return proto.CompactTextString(m) }
func (*IndexerAssetPosition) ProtoMessage()    {}
func (*IndexerAssetPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c5845963309ad8f, []int{2}
}
func (m *IndexerAssetPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexerAssetPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexerAssetPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexerAssetPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexerAssetPosition.Merge(m, src)
}
func (m *IndexerAssetPosition) XXX_Size() int {
	return m.Size()
}
func (m *IndexerAssetPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexerAssetPosition.DiscardUnknown(m)
}

var xxx_messageInfo_IndexerAssetPosition proto.InternalMessageInfo

func (m *IndexerAssetPosition) GetAssetId() uint32 {
	if m != nil {
		return m.AssetId
	}
	return 0
}

func (m *IndexerAssetPosition) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func init() {
	proto.RegisterType((*IndexerSubaccountId)(nil), "dydxprotocol.indexer.protocol.v1.IndexerSubaccountId")
	proto.RegisterType((*IndexerPerpetualPosition)(nil), "dydxprotocol.indexer.protocol.v1.IndexerPerpetualPosition")
	proto.RegisterType((*IndexerAssetPosition)(nil), "dydxprotocol.indexer.protocol.v1.IndexerAssetPosition")
}

func init() {
	proto.RegisterFile("dydxprotocol/indexer/protocol/v1/subaccount.proto", fileDescriptor_4c5845963309ad8f)
}

var fileDescriptor_4c5845963309ad8f = []byte{
	// 423 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x93, 0xbd, 0xae, 0xd3, 0x30,
	0x18, 0x86, 0x13, 0xce, 0x0f, 0x07, 0xd3, 0x82, 0x14, 0x22, 0x94, 0x73, 0x86, 0x9c, 0xd2, 0xa9,
	0x4b, 0x13, 0x55, 0x5c, 0x41, 0x3b, 0x20, 0x65, 0x41, 0x21, 0x91, 0x18, 0x90, 0x50, 0xe5, 0xc4,
	0x26, 0xb5, 0x48, 0xec, 0xe0, 0x9f, 0xd2, 0xc2, 0xc0, 0x2d, 0x70, 0x27, 0x2c, 0x6c, 0xdc, 0x40,
	0xc7, 0x8a, 0x09, 0x31, 0x54, 0xa8, 0xbd, 0x11, 0x54, 0x3b, 0x4d, 0x19, 0x98, 0x90, 0x2a, 0xb6,
	0x7c, 0x8f, 0xec, 0xef, 0xb1, 0xde, 0x57, 0x01, 0x23, 0xb4, 0x44, 0x8b, 0x9a, 0x33, 0xc9, 0x72,
	0x56, 0x86, 0x84, 0x22, 0xbc, 0xc0, 0x3c, 0x6c, 0xc1, 0x7c, 0x14, 0x0a, 0x95, 0xc1, 0x3c, 0x67,
	0x8a, 0xca, 0x40, 0x63, 0xa7, 0xf7, 0xe7, 0x95, 0xa0, 0xb9, 0x12, 0xb4, 0x60, 0x3e, 0xba, 0xb9,
	0xce, 0x99, 0xa8, 0x98, 0x98, 0x6a, 0x16, 0x9a, 0xc1, 0x1c, 0xb8, 0x71, 0x0b, 0x56, 0x30, 0xc3,
	0xf7, 0x5f, 0x86, 0xf6, 0x5f, 0x83, 0x47, 0x91, 0xd9, 0x93, 0xb6, 0xb6, 0x08, 0x39, 0x01, 0xb8,
	0x60, 0xef, 0x29, 0xe6, 0x9e, 0xdd, 0xb3, 0x07, 0xf7, 0x26, 0xde, 0xf7, 0xaf, 0x43, 0xb7, 0xd9,
	0x36, 0x46, 0x88, 0x63, 0x21, 0x52, 0xc9, 0x09, 0x2d, 0x12, 0x73, 0xcc, 0x79, 0x0c, 0x2e, 0xa9,
	0xaa, 0x32, 0xcc, 0xbd, 0x3b, 0x3d, 0x7b, 0xd0, 0x4d, 0x9a, 0xa9, 0xff, 0xe5, 0x0c, 0x78, 0xcd,
	0xfe, 0x18, 0xf3, 0x1a, 0x4b, 0x05, 0xcb, 0x98, 0x09, 0x22, 0x09, 0xa3, 0xce, 0x13, 0xd0, 0xa9,
	0x0f, 0x70, 0x4a, 0x90, 0x76, 0x75, 0x93, 0xfb, 0x2d, 0x8b, 0x90, 0xc3, 0xc1, 0xd5, 0x3b, 0x05,
	0xa9, 0x54, 0x95, 0xd0, 0x9b, 0x3b, 0x93, 0x97, 0xab, 0xcd, 0xad, 0xf5, 0x73, 0x73, 0xfb, 0xbc,
	0x20, 0x72, 0xa6, 0xb2, 0x20, 0x67, 0x55, 0x98, 0x4a, 0x8e, 0x61, 0xf5, 0x8c, 0x50, 0x48, 0x73,
	0x3c, 0x8c, 0x0f, 0x11, 0x0a, 0x8d, 0x87, 0xf9, 0x0c, 0x12, 0x7a, 0x0c, 0x16, 0xc9, 0x65, 0x8d,
	0x45, 0x90, 0x62, 0x4e, 0x60, 0x49, 0x3e, 0xc0, 0xac, 0xc4, 0x11, 0x95, 0x49, 0xeb, 0x71, 0x3e,
	0x82, 0xee, 0x1b, 0x45, 0x11, 0xa1, 0xc5, 0x54, 0x47, 0xec, 0x9d, 0x9d, 0x54, 0xdc, 0x69, 0x64,
	0x3a, 0x26, 0xe7, 0x13, 0x78, 0x78, 0x90, 0xd7, 0x70, 0x59, 0x61, 0x2a, 0xbd, 0xf3, 0x93, 0xea,
	0x1f, 0x34, 0xba, 0xd8, 0xd8, 0xfa, 0xdf, 0x6c, 0xe0, 0x36, 0x8d, 0x8d, 0x85, 0xc0, 0xb2, 0x6d,
	0xeb, 0x1a, 0x5c, 0xc1, 0x3d, 0x38, 0x36, 0x75, 0x57, 0xcf, 0xff, 0xa9, 0x25, 0x17, 0x5c, 0x1c,
	0xdb, 0x39, 0x4f, 0xcc, 0x30, 0x79, 0xbb, 0xda, 0xfa, 0xf6, 0x7a, 0xeb, 0xdb, 0xbf, 0xb6, 0xbe,
	0xfd, 0x79, 0xe7, 0x5b, 0xeb, 0x9d, 0x6f, 0xfd, 0xd8, 0xf9, 0xd6, 0xab, 0x17, 0xff, 0xfa, 0x92,
	0xbf, 0xfd, 0x99, 0xfa, 0x71, 0xd9, 0xa5, 0x46, 0x4f, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x87,
	0x87, 0xa6, 0xc0, 0xca, 0x03, 0x00, 0x00,
}

func (m *IndexerSubaccountId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexerSubaccountId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexerSubaccountId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		i = encodeVarintSubaccount(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintSubaccount(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexerPerpetualPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexerPerpetualPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexerPerpetualPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FundingPayment.Size()
		i -= size
		if _, err := m.FundingPayment.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSubaccount(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FundingIndex.Size()
		i -= size
		if _, err := m.FundingIndex.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSubaccount(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Quantums.Size()
		i -= size
		if _, err := m.Quantums.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSubaccount(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PerpetualId != 0 {
		i = encodeVarintSubaccount(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexerAssetPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexerAssetPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexerAssetPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintSubaccount(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Quantums.Size()
		i -= size
		if _, err := m.Quantums.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSubaccount(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.AssetId != 0 {
		i = encodeVarintSubaccount(dAtA, i, uint64(m.AssetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSubaccount(dAtA []byte, offset int, v uint64) int {
	offset -= sovSubaccount(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IndexerSubaccountId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSubaccount(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovSubaccount(uint64(m.Number))
	}
	return n
}

func (m *IndexerPerpetualPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerpetualId != 0 {
		n += 1 + sovSubaccount(uint64(m.PerpetualId))
	}
	l = m.Quantums.Size()
	n += 1 + l + sovSubaccount(uint64(l))
	l = m.FundingIndex.Size()
	n += 1 + l + sovSubaccount(uint64(l))
	l = m.FundingPayment.Size()
	n += 1 + l + sovSubaccount(uint64(l))
	return n
}

func (m *IndexerAssetPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetId != 0 {
		n += 1 + sovSubaccount(uint64(m.AssetId))
	}
	l = m.Quantums.Size()
	n += 1 + l + sovSubaccount(uint64(l))
	if m.Index != 0 {
		n += 1 + sovSubaccount(uint64(m.Index))
	}
	return n
}

func sovSubaccount(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSubaccount(x uint64) (n int) {
	return sovSubaccount(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IndexerSubaccountId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexerSubaccountId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexerSubaccountId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubaccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexerPerpetualPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexerPerpetualPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexerPerpetualPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantums", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubaccount
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantums.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubaccount
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingPayment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubaccount
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingPayment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexerAssetPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubaccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexerAssetPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexerAssetPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			m.AssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantums", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubaccount
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubaccount
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantums.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubaccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubaccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubaccount(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubaccount
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubaccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSubaccount
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSubaccount
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSubaccount
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSubaccount        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubaccount          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSubaccount = fmt.Errorf("proto: unexpected end of group")
)
