"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clobStatusToMarketStatus = exports.orderTypeToProtocolConditionType = exports.protocolConditionTypeToOrderType = exports.getGoodTilBlockTime = exports.getGoodTilBlock = exports.tifToProtocolOrderTIF = exports.protocolOrderTIFToTIF = exports.protocolOrderSideToOrderSide = exports.protocolPriceToHuman = exports.humanToQuantums = exports.quantumsToHuman = exports.serializedQuantumsToAbsHumanFixedString = exports.quantumsToHumanFixedString = exports.getStepSize = exports.funding8HourValuePpmTo1HourRate = exports.fundingIndexToHumanFixedString = exports.getTickSize = exports.priceToSubticks = exports.subticksToPrice = void 0;
const v4_proto_parser_1 = require("@dydxprotocol-indexer/v4-proto-parser");
const v4_protos_1 = require("@dydxprotocol-indexer/v4-protos");
const big_js_1 = __importDefault(require("big.js"));
const luxon_1 = require("luxon");
const constants_1 = require("../constants");
const types_1 = require("../types");
const errors_1 = require("./errors");
// Mapping from the TimeInForce enum from the protocol to the TimeInForce enum in the Indexer
const PROTOCOL_TIF_TO_INDEXER_TIF_MAP = {
    [v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_FILL_OR_KILL]: types_1.TimeInForce.FOK,
    [v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_IOC]: types_1.TimeInForce.IOC,
    // Default behavior with UNSPECIFIED = GTT (Good-Til-Time)
    [v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_UNSPECIFIED]: types_1.TimeInForce.GTT,
    [v4_protos_1.IndexerOrder_TimeInForce.UNRECOGNIZED]: types_1.TimeInForce.GTT,
    [v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_POST_ONLY]: types_1.TimeInForce.POST_ONLY,
};
// Reverse mapping of above
const INDEXER_TIF_TO_PROTOCOL_TIF_MAP = {
    [types_1.TimeInForce.FOK]: v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_FILL_OR_KILL,
    [types_1.TimeInForce.IOC]: v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_IOC,
    [types_1.TimeInForce.GTT]: v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_UNSPECIFIED,
    [types_1.TimeInForce.POST_ONLY]: v4_protos_1.IndexerOrder_TimeInForce.TIME_IN_FORCE_POST_ONLY,
};
// Mapping from Condition type enum from protocol to OrderType enum in the Indexer
const CONDITION_TYPE_TO_ORDER_TYPE_MAP = {
    // Default behavior with UNSPECIFIED / UNRECOGNIZED = Limit Order
    [v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_UNSPECIFIED]: types_1.OrderType.LIMIT,
    [v4_protos_1.IndexerOrder_ConditionType.UNRECOGNIZED]: types_1.OrderType.LIMIT,
    [v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_STOP_LOSS]: types_1.OrderType.STOP_LIMIT,
    [v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_TAKE_PROFIT]: types_1.OrderType.TAKE_PROFIT,
};
// Reverse mapping of above
const ORDER_TYPE_TO_CONDITION_TYPE_MAP = {
    // Limit orders are unspecified
    [types_1.OrderType.LIMIT]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    // Only STOP_LIMIT is used currently
    [types_1.OrderType.STOP_LIMIT]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_STOP_LOSS,
    [types_1.OrderType.STOP_MARKET]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_STOP_LOSS,
    // Only TAKE_PROFIT is used currently
    [types_1.OrderType.TAKE_PROFIT]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_TAKE_PROFIT,
    [types_1.OrderType.TAKE_PROFIT_MARKET]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_TAKE_PROFIT,
    // TODO(IND-356): Remove irrelevant order types
    // Unused order types
    [types_1.OrderType.HARD_TRADE]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    [types_1.OrderType.FAILED_HARD_TRADE]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    [types_1.OrderType.MARKET]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    [types_1.OrderType.TRANSFER_PLACEHOLDER]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_UNSPECIFIED,
    [types_1.OrderType.TRAILING_STOP]: v4_protos_1.IndexerOrder_ConditionType.CONDITION_TYPE_UNSPECIFIED,
};
/**
 * @param subticks - quote quantums/base quantums e.g. (1e-14 USDC/1e-10 BTC)
 * @returns - quote currency / base currency (human readable price)
 */
function subticksToPrice(subticks, perpetualMarket) {
    return (0, big_js_1.default)(subticks)
        .times((0, big_js_1.default)(10).pow(perpetualMarket.quantumConversionExponent))
        .times((0, big_js_1.default)(10).pow(constants_1.QUOTE_CURRENCY_ATOMIC_RESOLUTION))
        .div((0, big_js_1.default)(10).pow(perpetualMarket.atomicResolution))
        .toFixed();
}
exports.subticksToPrice = subticksToPrice;
/**
 * @param price - quote currency / base currency (human readable price)
 * @returns - quote quantums/base quantums e.g. (1e-14 USDC/1e-10 BTC)
 */
function priceToSubticks(price, perpetualMarket) {
    return (0, big_js_1.default)(price)
        .times((0, big_js_1.default)(10).pow(perpetualMarket.atomicResolution))
        .div((0, big_js_1.default)(10).pow(constants_1.QUOTE_CURRENCY_ATOMIC_RESOLUTION))
        .div((0, big_js_1.default)(10).pow(perpetualMarket.quantumConversionExponent))
        .toFixed();
}
exports.priceToSubticks = priceToSubticks;
/**
 * @param perpetualMarket
 * @returns - tick size for a given perpetual market. Tick size is the minimum price movement on
 * the market in quote human.
 */
function getTickSize(perpetualMarket) {
    return (0, big_js_1.default)(perpetualMarket.subticksPerTick)
        .times((0, big_js_1.default)(10).pow(perpetualMarket.quantumConversionExponent))
        .times((0, big_js_1.default)(10).pow(constants_1.QUOTE_CURRENCY_ATOMIC_RESOLUTION))
        .div((0, big_js_1.default)(10).pow(perpetualMarket.atomicResolution))
        .toFixed();
}
exports.getTickSize = getTickSize;
/**
 * Given a funding index from the protocol, convert it to a human readable units such that when
 * multiplied by the position size in human-readable units of the base currency (e.g. 1 ETH, 1 BTC)
 * results in the funding payment in human-readable units of the quote currency (e.g. 1.2 USDC).
 * The funding index from the protocol is in parts-per-million, and of the units
 * quote-quantums / base quantums.
 * Formula for funding payment:
 * F_Q = funding payment in quote quantums
 * F_Q_H = funding payment in human-readable units of the quote currency
 * R_Q = atomic resolution of quote currency
 * P_B = position size in base quantums
 * P_B_H = position size in human-readable units of the base currency
 * R_B = atomic resolution of base currency
 * FI = funding index from protocol
 * FI_H = funding index in human-readable units, such that when multipled by the position size in
 * human-readable units of the base currency, returns the funding payment in human-readable units of
 * the quote currency.
 *
 * F_Q_H = F_Q * (10 ^ R_Q) -> formula to get funding payment in human-readable units
 * P_B_H = P_B * (10 ^ R_B) -> formula to get position size in human-readable units
 * F_Q = P_B * (FI / 10 ^ 6) -> formula to get funding payment from funding index and position size
 * F_Q_H = P_B_H * (FI_H) -> desired formula with funding index in human-readable units
 *
 * Note: in F_Q = P_B * (FI * 10 ^ 6), we divide by 10^6 as funding index from protocol is in
 * parts-per-million.
 * Solving for FI_H, we get
 * FI_H = F_Q_H / P_B_H
 * FI_H = (F_Q * 10 ^ R_Q) / (P_B * 10 ^ R_B)
 * FI_H = ((P_B * (FI / 10 ^ 6)) *  10 ^ R_Q) / (P_B * 10 ^ R_B)
 * FI_H = ((FI / 10 ^ 6) * 10 ^ R_Q) / (10 ^ R_B)
 * FI_H = (FI * 10 ^ -6 * 10 ^ R_Q) / (10 ^ R_B) -> formula for human-readable funding index using
 * resolutions of base and quote currency along with the funding-index from the protocol
 * @param fundingIndex
 * @param perpetualMarket
 */
function fundingIndexToHumanFixedString(fundingIndex, perpetualMarket) {
    return (0, big_js_1.default)(fundingIndex)
        .times((0, big_js_1.default)(10).pow(constants_1.PPM_EXPONENT)) // PPM = parts-per-million
        .times((0, big_js_1.default)(10).pow(constants_1.QUOTE_CURRENCY_ATOMIC_RESOLUTION))
        .div((0, big_js_1.default)(10).pow(perpetualMarket.atomicResolution))
        .toFixed();
}
exports.fundingIndexToHumanFixedString = fundingIndexToHumanFixedString;
/**
 * Given a funding value in parts-per-million, convert it to a funding index in human-readable
 * units. This formula requires dividing ppm by 1^6 and also dividing by 8 as funding is returned
 * in 8 hour and we store funding rate in 1 hour increments.
 */
function funding8HourValuePpmTo1HourRate(fundingValuePpm) {
    return (0, big_js_1.default)(fundingValuePpm)
        .times((0, big_js_1.default)(10).pow(constants_1.PPM_EXPONENT))
        .div(constants_1.FUNDING_RATE_FROM_PROTOCOL_IN_HOURS)
        .toFixed();
}
exports.funding8HourValuePpmTo1HourRate = funding8HourValuePpmTo1HourRate;
/**
 * Returns the step size for the given perpetual market.
 * Step size is the smallest factor allowed for order amounts on the market in human.
 * @param perpetualMarket
 * @returns
 */
function getStepSize(perpetualMarket) {
    return (0, big_js_1.default)(perpetualMarket.stepBaseQuantums)
        .times((0, big_js_1.default)(10).pow(perpetualMarket.atomicResolution))
        .toFixed();
}
exports.getStepSize = getStepSize;
function quantumsToHumanFixedString(baseQuantums, atomicResolution) {
    return quantumsToHuman(baseQuantums, atomicResolution).toFixed();
}
exports.quantumsToHumanFixedString = quantumsToHumanFixedString;
/**
 * Returns the absolute human-readable size in string form, from the serialized
 * quantums buffer received from the protocol. This is a temporary function until
 * DEC-1597 (deprecate `isLong`) is completed.
 * @param serializedQuantums The serialized quantums buffer from the protocol
 * @param atomicResolution atomic resolution of the market
 * @returns absolute human-readable size
 */
function serializedQuantumsToAbsHumanFixedString(serializedQuantums, atomicResolution) {
    return quantumsToHuman((0, v4_proto_parser_1.bytesToBigInt)(serializedQuantums).toString(), atomicResolution).abs().toFixed();
}
exports.serializedQuantumsToAbsHumanFixedString = serializedQuantumsToAbsHumanFixedString;
/**
 * @param quantums - the smallest increment of position size, and is determined by atomicResolution.
 * For example, an atomicResolution of 8 means the smallest increment of position size is 1e-8.
 * @returns - human readable position size
 */
function quantumsToHuman(quantums, atomicResolution) {
    return (0, big_js_1.default)(quantums)
        .times((0, big_js_1.default)(10).pow(atomicResolution));
}
exports.quantumsToHuman = quantumsToHuman;
function humanToQuantums(human, atomicResolution) {
    return (0, big_js_1.default)(human)
        .div((0, big_js_1.default)(10).pow(atomicResolution));
}
exports.humanToQuantums = humanToQuantums;
/**
 * Converts a price from the `Price` module in the V4 protocol to a human readable price.
 * @param protocolPrice Price value from the `Price` module.
 * @param exponent Exponent for the price from the `Price` module.
 * @returns Human readable price as a string.
 */
function protocolPriceToHuman(protocolPrice, exponent) {
    return (0, big_js_1.default)(protocolPrice)
        .times((0, big_js_1.default)(10).pow(exponent))
        .toFixed();
}
exports.protocolPriceToHuman = protocolPriceToHuman;
/**
 * Converts the `Order_Side` enum from the protobuf to the `OrderSide` enum in postgres
 * @param protocolOrderSide `IndexerOrder_Side` enum from protobuf
 * @returns `OrderSide` corresponding to the `Order_Side` passed in
 */
function protocolOrderSideToOrderSide(protocolOrderSide) {
    return protocolOrderSide === v4_protos_1.IndexerOrder_Side.SIDE_BUY ? types_1.OrderSide.BUY : types_1.OrderSide.SELL;
}
exports.protocolOrderSideToOrderSide = protocolOrderSideToOrderSide;
/**
 * Converts the TimeInForce field from an IndexerOrder proto to a TimeInForce enum in the Indexer.
 * Special cased:
 * - UNSPECIFIED -> GTT
 * Throw an error if the input TimeInForce enum is not in the known enum values for TimeInForce.
 * @param protocolOrderTIF
 * @returns
 */
function protocolOrderTIFToTIF(protocolOrderTIF) {
    if (!(protocolOrderTIF in PROTOCOL_TIF_TO_INDEXER_TIF_MAP)) {
        throw new Error(`Unexpected TimeInForce from protocol: ${protocolOrderTIF}`);
    }
    return PROTOCOL_TIF_TO_INDEXER_TIF_MAP[protocolOrderTIF];
}
exports.protocolOrderTIFToTIF = protocolOrderTIFToTIF;
/**
 * Converts TimeInForce enum in the Indexer to the TimeInForce field from an IndexerOrder proto.
 * GTT -> UNSPECIFIED.
 * Throw an error if the input TimeInForce enum is not in the known enum values for TimeInForce.
 * @param timeInForce
 */
function tifToProtocolOrderTIF(timeInForce) {
    if (!(timeInForce in INDEXER_TIF_TO_PROTOCOL_TIF_MAP)) {
        throw new Error(`Unexpected TimeInForce: ${timeInForce}`);
    }
    return INDEXER_TIF_TO_PROTOCOL_TIF_MAP[timeInForce];
}
exports.tifToProtocolOrderTIF = tifToProtocolOrderTIF;
// Gets `goodTilBlock` from an `IndexerOrder`, undefined if it does not exist.
function getGoodTilBlock(order) {
    return order.goodTilBlock;
}
exports.getGoodTilBlock = getGoodTilBlock;
// Gets `goodTilBlockTime` from an `Order` as an ISO string, undefined if it does not exist.
function getGoodTilBlockTime(order) {
    if (order.goodTilBlockTime !== undefined) {
        // `goodTilBlockTime` is the unix timestamp in seconds
        // Reference:
        // https://github.com/dydxprotocol/v4/blob/main/proto/dydxprotocol/clob/order.proto#L138-L144
        return luxon_1.DateTime.fromSeconds(order.goodTilBlockTime).toUTC().toISO();
    }
    return undefined;
}
exports.getGoodTilBlockTime = getGoodTilBlockTime;
/**
 * Converts ConditionType enum from an IndexerOrder proto to an OrderType in the Indexer.
 * Special cased:
 * - UNSPECIFIED -> LIMIT
 * Throw an error if the input ConditionType is not in the known enum values for ConditionType.
 * @param protocolConditionType
 * @returns
 */
function protocolConditionTypeToOrderType(protocolConditionType) {
    if (!(protocolConditionType in CONDITION_TYPE_TO_ORDER_TYPE_MAP)) {
        throw new Error(`Unexpected ConditionType: ${protocolConditionType}`);
    }
    return CONDITION_TYPE_TO_ORDER_TYPE_MAP[protocolConditionType];
}
exports.protocolConditionTypeToOrderType = protocolConditionTypeToOrderType;
/**
 * Converts OrderType enum to protocol ConditionType.
 * Special cased:
 * - all unused types (not LIMIT / STOP-LIMIT/MARKET / TAKE-PROFIT (MARKET)) default to unspecified
 * - STOP_LIMIT and STOP_MARKET map to STOP_LOSS
 * - TAKE_PROFIT and TAKE_PROFIT_MARKET map to TAKE_PROFIT
 * @param orderType
 * @returns
 */
function orderTypeToProtocolConditionType(orderType) {
    if (!(orderType in ORDER_TYPE_TO_CONDITION_TYPE_MAP)) {
        throw new Error(`Unexpected OrderType: ${orderType}`);
    }
    return ORDER_TYPE_TO_CONDITION_TYPE_MAP[orderType];
}
exports.orderTypeToProtocolConditionType = orderTypeToProtocolConditionType;
function clobStatusToMarketStatus(clobPairStatus) {
    if (clobPairStatus !== v4_protos_1.ClobPairStatus.CLOB_PAIR_STATUS_UNSPECIFIED &&
        clobPairStatus !== v4_protos_1.ClobPairStatus.UNRECOGNIZED &&
        clobPairStatus in constants_1.CLOB_STATUS_TO_MARKET_STATUS) {
        return constants_1.CLOB_STATUS_TO_MARKET_STATUS[clobPairStatus];
    }
    else {
        throw new errors_1.InvalidClobPairStatusError(clobPairStatus);
    }
}
exports.clobStatusToMarketStatus = clobStatusToMarketStatus;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdG9jb2wtdHJhbnNsYXRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9wcm90b2NvbC10cmFuc2xhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMkVBQXNFO0FBQ3RFLCtEQU15QztBQUN6QyxvREFBeUI7QUFDekIsaUNBQWlDO0FBRWpDLDRDQUtzQjtBQUN0QixvQ0FFa0I7QUFDbEIscUNBQXNEO0FBRXRELDZGQUE2RjtBQUM3RixNQUFNLCtCQUErQixHQUFrRDtJQUNyRixDQUFDLG9DQUF3QixDQUFDLDBCQUEwQixDQUFDLEVBQUUsbUJBQVcsQ0FBQyxHQUFHO0lBQ3RFLENBQUMsb0NBQXdCLENBQUMsaUJBQWlCLENBQUMsRUFBRSxtQkFBVyxDQUFDLEdBQUc7SUFDN0QsMERBQTBEO0lBQzFELENBQUMsb0NBQXdCLENBQUMseUJBQXlCLENBQUMsRUFBRSxtQkFBVyxDQUFDLEdBQUc7SUFDckUsQ0FBQyxvQ0FBd0IsQ0FBQyxZQUFZLENBQUMsRUFBRSxtQkFBVyxDQUFDLEdBQUc7SUFDeEQsQ0FBQyxvQ0FBd0IsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLG1CQUFXLENBQUMsU0FBUztDQUMxRSxDQUFDO0FBRUYsMkJBQTJCO0FBQzNCLE1BQU0sK0JBQStCLEdBQWtEO0lBQ3JGLENBQUMsbUJBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxvQ0FBd0IsQ0FBQywwQkFBMEI7SUFDdEUsQ0FBQyxtQkFBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLG9DQUF3QixDQUFDLGlCQUFpQjtJQUM3RCxDQUFDLG1CQUFXLENBQUMsR0FBRyxDQUFDLEVBQUUsb0NBQXdCLENBQUMseUJBQXlCO0lBQ3JFLENBQUMsbUJBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRSxvQ0FBd0IsQ0FBQyx1QkFBdUI7Q0FDMUUsQ0FBQztBQUVGLGtGQUFrRjtBQUNsRixNQUFNLGdDQUFnQyxHQUFrRDtJQUN0RixpRUFBaUU7SUFD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