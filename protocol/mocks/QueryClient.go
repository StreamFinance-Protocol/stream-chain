// Code generated by mockery v2.42.0. DO NOT EDIT.

package mocks

import (
	api "github.com/StreamFinance-Protocol/stream-chain/protocol/daemons/bridge/api"
	blocktimetypes "github.com/StreamFinance-Protocol/stream-chain/protocol/x/blocktime/types"

	clobtypes "github.com/StreamFinance-Protocol/stream-chain/protocol/x/clob/types"

	context "context"

	deleveragingapi "github.com/StreamFinance-Protocol/stream-chain/protocol/daemons/deleveraging/api"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	pricefeedapi "github.com/StreamFinance-Protocol/stream-chain/protocol/daemons/pricefeed/api"

	pricestypes "github.com/StreamFinance-Protocol/stream-chain/protocol/x/prices/types"

	ratelimittypes "github.com/StreamFinance-Protocol/stream-chain/protocol/x/ratelimit/types"

	subaccountstypes "github.com/StreamFinance-Protocol/stream-chain/protocol/x/subaccounts/types"

	types "github.com/StreamFinance-Protocol/stream-chain/protocol/x/perpetuals/types"
)

// QueryClient is an autogenerated mock type for the QueryClient type
type QueryClient struct {
	mock.Mock
}

// AddBridgeEvents provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AddBridgeEvents(ctx context.Context, in *api.AddBridgeEventsRequest, opts ...grpc.CallOption) (*api.AddBridgeEventsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddBridgeEvents")
	}

	var r0 *api.AddBridgeEventsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.AddBridgeEventsRequest, ...grpc.CallOption) (*api.AddBridgeEventsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.AddBridgeEventsRequest, ...grpc.CallOption) *api.AddBridgeEventsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AddBridgeEventsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.AddBridgeEventsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllCollateralPools provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AllCollateralPools(ctx context.Context, in *types.QueryAllCollateralPoolsRequest, opts ...grpc.CallOption) (*types.QueryAllCollateralPoolsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllCollateralPools")
	}

	var r0 *types.QueryAllCollateralPoolsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAllCollateralPoolsRequest, ...grpc.CallOption) (*types.QueryAllCollateralPoolsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAllCollateralPoolsRequest, ...grpc.CallOption) *types.QueryAllCollateralPoolsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryAllCollateralPoolsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryAllCollateralPoolsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllDowntimeInfo provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AllDowntimeInfo(ctx context.Context, in *blocktimetypes.QueryAllDowntimeInfoRequest, opts ...grpc.CallOption) (*blocktimetypes.QueryAllDowntimeInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllDowntimeInfo")
	}

	var r0 *blocktimetypes.QueryAllDowntimeInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *blocktimetypes.QueryAllDowntimeInfoRequest, ...grpc.CallOption) (*blocktimetypes.QueryAllDowntimeInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *blocktimetypes.QueryAllDowntimeInfoRequest, ...grpc.CallOption) *blocktimetypes.QueryAllDowntimeInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blocktimetypes.QueryAllDowntimeInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *blocktimetypes.QueryAllDowntimeInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllLiquidityTiers provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AllLiquidityTiers(ctx context.Context, in *types.QueryAllLiquidityTiersRequest, opts ...grpc.CallOption) (*types.QueryAllLiquidityTiersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllLiquidityTiers")
	}

	var r0 *types.QueryAllLiquidityTiersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAllLiquidityTiersRequest, ...grpc.CallOption) (*types.QueryAllLiquidityTiersResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAllLiquidityTiersRequest, ...grpc.CallOption) *types.QueryAllLiquidityTiersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryAllLiquidityTiersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryAllLiquidityTiersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllMarketParams provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AllMarketParams(ctx context.Context, in *pricestypes.QueryAllMarketParamsRequest, opts ...grpc.CallOption) (*pricestypes.QueryAllMarketParamsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllMarketParams")
	}

	var r0 *pricestypes.QueryAllMarketParamsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryAllMarketParamsRequest, ...grpc.CallOption) (*pricestypes.QueryAllMarketParamsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryAllMarketParamsRequest, ...grpc.CallOption) *pricestypes.QueryAllMarketParamsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pricestypes.QueryAllMarketParamsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pricestypes.QueryAllMarketParamsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllMarketPrices provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AllMarketPrices(ctx context.Context, in *pricestypes.QueryAllMarketPricesRequest, opts ...grpc.CallOption) (*pricestypes.QueryAllMarketPricesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllMarketPrices")
	}

	var r0 *pricestypes.QueryAllMarketPricesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryAllMarketPricesRequest, ...grpc.CallOption) (*pricestypes.QueryAllMarketPricesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryAllMarketPricesRequest, ...grpc.CallOption) *pricestypes.QueryAllMarketPricesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pricestypes.QueryAllMarketPricesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pricestypes.QueryAllMarketPricesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllPendingSendPackets provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AllPendingSendPackets(ctx context.Context, in *ratelimittypes.QueryAllPendingSendPacketsRequest, opts ...grpc.CallOption) (*ratelimittypes.QueryAllPendingSendPacketsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllPendingSendPackets")
	}

	var r0 *ratelimittypes.QueryAllPendingSendPacketsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.QueryAllPendingSendPacketsRequest, ...grpc.CallOption) (*ratelimittypes.QueryAllPendingSendPacketsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.QueryAllPendingSendPacketsRequest, ...grpc.CallOption) *ratelimittypes.QueryAllPendingSendPacketsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ratelimittypes.QueryAllPendingSendPacketsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ratelimittypes.QueryAllPendingSendPacketsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllPerpetuals provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) AllPerpetuals(ctx context.Context, in *types.QueryAllPerpetualsRequest, opts ...grpc.CallOption) (*types.QueryAllPerpetualsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllPerpetuals")
	}

	var r0 *types.QueryAllPerpetualsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAllPerpetualsRequest, ...grpc.CallOption) (*types.QueryAllPerpetualsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryAllPerpetualsRequest, ...grpc.CallOption) *types.QueryAllPerpetualsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryAllPerpetualsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryAllPerpetualsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockRateLimitConfiguration provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) BlockRateLimitConfiguration(ctx context.Context, in *clobtypes.QueryBlockRateLimitConfigurationRequest, opts ...grpc.CallOption) (*clobtypes.QueryBlockRateLimitConfigurationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BlockRateLimitConfiguration")
	}

	var r0 *clobtypes.QueryBlockRateLimitConfigurationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryBlockRateLimitConfigurationRequest, ...grpc.CallOption) (*clobtypes.QueryBlockRateLimitConfigurationResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryBlockRateLimitConfigurationRequest, ...grpc.CallOption) *clobtypes.QueryBlockRateLimitConfigurationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.QueryBlockRateLimitConfigurationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *clobtypes.QueryBlockRateLimitConfigurationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapacityByDenom provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) CapacityByDenom(ctx context.Context, in *ratelimittypes.QueryCapacityByDenomRequest, opts ...grpc.CallOption) (*ratelimittypes.QueryCapacityByDenomResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CapacityByDenom")
	}

	var r0 *ratelimittypes.QueryCapacityByDenomResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.QueryCapacityByDenomRequest, ...grpc.CallOption) (*ratelimittypes.QueryCapacityByDenomResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.QueryCapacityByDenomRequest, ...grpc.CallOption) *ratelimittypes.QueryCapacityByDenomResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ratelimittypes.QueryCapacityByDenomResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ratelimittypes.QueryCapacityByDenomRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClobPair provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) ClobPair(ctx context.Context, in *clobtypes.QueryGetClobPairRequest, opts ...grpc.CallOption) (*clobtypes.QueryClobPairResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClobPair")
	}

	var r0 *clobtypes.QueryClobPairResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryGetClobPairRequest, ...grpc.CallOption) (*clobtypes.QueryClobPairResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryGetClobPairRequest, ...grpc.CallOption) *clobtypes.QueryClobPairResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.QueryClobPairResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *clobtypes.QueryGetClobPairRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClobPairAll provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) ClobPairAll(ctx context.Context, in *clobtypes.QueryAllClobPairRequest, opts ...grpc.CallOption) (*clobtypes.QueryClobPairAllResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClobPairAll")
	}

	var r0 *clobtypes.QueryClobPairAllResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryAllClobPairRequest, ...grpc.CallOption) (*clobtypes.QueryClobPairAllResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryAllClobPairRequest, ...grpc.CallOption) *clobtypes.QueryClobPairAllResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.QueryClobPairAllResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *clobtypes.QueryAllClobPairRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CollateralPoolAddress provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) CollateralPoolAddress(ctx context.Context, in *subaccountstypes.QueryCollateralPoolAddressRequest, opts ...grpc.CallOption) (*subaccountstypes.QueryCollateralPoolAddressResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CollateralPoolAddress")
	}

	var r0 *subaccountstypes.QueryCollateralPoolAddressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryCollateralPoolAddressRequest, ...grpc.CallOption) (*subaccountstypes.QueryCollateralPoolAddressResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryCollateralPoolAddressRequest, ...grpc.CallOption) *subaccountstypes.QueryCollateralPoolAddressResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*subaccountstypes.QueryCollateralPoolAddressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *subaccountstypes.QueryCollateralPoolAddressRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DowntimeParams provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) DowntimeParams(ctx context.Context, in *blocktimetypes.QueryDowntimeParamsRequest, opts ...grpc.CallOption) (*blocktimetypes.QueryDowntimeParamsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DowntimeParams")
	}

	var r0 *blocktimetypes.QueryDowntimeParamsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *blocktimetypes.QueryDowntimeParamsRequest, ...grpc.CallOption) (*blocktimetypes.QueryDowntimeParamsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *blocktimetypes.QueryDowntimeParamsRequest, ...grpc.CallOption) *blocktimetypes.QueryDowntimeParamsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blocktimetypes.QueryDowntimeParamsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *blocktimetypes.QueryDowntimeParamsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EquityTierLimitConfiguration provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) EquityTierLimitConfiguration(ctx context.Context, in *clobtypes.QueryEquityTierLimitConfigurationRequest, opts ...grpc.CallOption) (*clobtypes.QueryEquityTierLimitConfigurationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EquityTierLimitConfiguration")
	}

	var r0 *clobtypes.QueryEquityTierLimitConfigurationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryEquityTierLimitConfigurationRequest, ...grpc.CallOption) (*clobtypes.QueryEquityTierLimitConfigurationResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryEquityTierLimitConfigurationRequest, ...grpc.CallOption) *clobtypes.QueryEquityTierLimitConfigurationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.QueryEquityTierLimitConfigurationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *clobtypes.QueryEquityTierLimitConfigurationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssetYieldIndexQuery provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetAssetYieldIndexQuery(ctx context.Context, in *ratelimittypes.GetAssetYieldIndexQueryRequest, opts ...grpc.CallOption) (*ratelimittypes.GetAssetYieldIndexQueryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssetYieldIndexQuery")
	}

	var r0 *ratelimittypes.GetAssetYieldIndexQueryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.GetAssetYieldIndexQueryRequest, ...grpc.CallOption) (*ratelimittypes.GetAssetYieldIndexQueryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.GetAssetYieldIndexQueryRequest, ...grpc.CallOption) *ratelimittypes.GetAssetYieldIndexQueryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ratelimittypes.GetAssetYieldIndexQueryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ratelimittypes.GetAssetYieldIndexQueryRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSDAIPriceQuery provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetSDAIPriceQuery(ctx context.Context, in *ratelimittypes.GetSDAIPriceQueryRequest, opts ...grpc.CallOption) (*ratelimittypes.GetSDAIPriceQueryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSDAIPriceQuery")
	}

	var r0 *ratelimittypes.GetSDAIPriceQueryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.GetSDAIPriceQueryRequest, ...grpc.CallOption) (*ratelimittypes.GetSDAIPriceQueryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.GetSDAIPriceQueryRequest, ...grpc.CallOption) *ratelimittypes.GetSDAIPriceQueryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ratelimittypes.GetSDAIPriceQueryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ratelimittypes.GetSDAIPriceQueryRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWithdrawalAndTransfersBlockedInfo provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) GetWithdrawalAndTransfersBlockedInfo(ctx context.Context, in *subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoRequest, opts ...grpc.CallOption) (*subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWithdrawalAndTransfersBlockedInfo")
	}

	var r0 *subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoRequest, ...grpc.CallOption) (*subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoRequest, ...grpc.CallOption) *subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *subaccountstypes.QueryGetWithdrawalAndTransfersBlockedInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LiquidationsConfiguration provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) LiquidationsConfiguration(ctx context.Context, in *clobtypes.QueryLiquidationsConfigurationRequest, opts ...grpc.CallOption) (*clobtypes.QueryLiquidationsConfigurationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LiquidationsConfiguration")
	}

	var r0 *clobtypes.QueryLiquidationsConfigurationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryLiquidationsConfigurationRequest, ...grpc.CallOption) (*clobtypes.QueryLiquidationsConfigurationResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.QueryLiquidationsConfigurationRequest, ...grpc.CallOption) *clobtypes.QueryLiquidationsConfigurationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.QueryLiquidationsConfigurationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *clobtypes.QueryLiquidationsConfigurationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLimitParams provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) ListLimitParams(ctx context.Context, in *ratelimittypes.ListLimitParamsRequest, opts ...grpc.CallOption) (*ratelimittypes.ListLimitParamsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListLimitParams")
	}

	var r0 *ratelimittypes.ListLimitParamsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.ListLimitParamsRequest, ...grpc.CallOption) (*ratelimittypes.ListLimitParamsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ratelimittypes.ListLimitParamsRequest, ...grpc.CallOption) *ratelimittypes.ListLimitParamsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ratelimittypes.ListLimitParamsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ratelimittypes.ListLimitParamsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarketParam provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) MarketParam(ctx context.Context, in *pricestypes.QueryMarketParamRequest, opts ...grpc.CallOption) (*pricestypes.QueryMarketParamResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MarketParam")
	}

	var r0 *pricestypes.QueryMarketParamResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryMarketParamRequest, ...grpc.CallOption) (*pricestypes.QueryMarketParamResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryMarketParamRequest, ...grpc.CallOption) *pricestypes.QueryMarketParamResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pricestypes.QueryMarketParamResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pricestypes.QueryMarketParamRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarketPrice provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) MarketPrice(ctx context.Context, in *pricestypes.QueryMarketPriceRequest, opts ...grpc.CallOption) (*pricestypes.QueryMarketPriceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MarketPrice")
	}

	var r0 *pricestypes.QueryMarketPriceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryMarketPriceRequest, ...grpc.CallOption) (*pricestypes.QueryMarketPriceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pricestypes.QueryMarketPriceRequest, ...grpc.CallOption) *pricestypes.QueryMarketPriceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pricestypes.QueryMarketPriceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pricestypes.QueryMarketPriceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MevNodeToNodeCalculation provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) MevNodeToNodeCalculation(ctx context.Context, in *clobtypes.MevNodeToNodeCalculationRequest, opts ...grpc.CallOption) (*clobtypes.MevNodeToNodeCalculationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MevNodeToNodeCalculation")
	}

	var r0 *clobtypes.MevNodeToNodeCalculationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.MevNodeToNodeCalculationRequest, ...grpc.CallOption) (*clobtypes.MevNodeToNodeCalculationResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.MevNodeToNodeCalculationRequest, ...grpc.CallOption) *clobtypes.MevNodeToNodeCalculationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.MevNodeToNodeCalculationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *clobtypes.MevNodeToNodeCalculationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Params provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) Params(ctx context.Context, in *types.QueryParamsRequest, opts ...grpc.CallOption) (*types.QueryParamsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Params")
	}

	var r0 *types.QueryParamsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) (*types.QueryParamsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) *types.QueryParamsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryParamsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryParamsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Perpetual provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) Perpetual(ctx context.Context, in *types.QueryPerpetualRequest, opts ...grpc.CallOption) (*types.QueryPerpetualResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Perpetual")
	}

	var r0 *types.QueryPerpetualResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryPerpetualRequest, ...grpc.CallOption) (*types.QueryPerpetualResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryPerpetualRequest, ...grpc.CallOption) *types.QueryPerpetualResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryPerpetualResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryPerpetualRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PremiumSamples provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) PremiumSamples(ctx context.Context, in *types.QueryPremiumSamplesRequest, opts ...grpc.CallOption) (*types.QueryPremiumSamplesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PremiumSamples")
	}

	var r0 *types.QueryPremiumSamplesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryPremiumSamplesRequest, ...grpc.CallOption) (*types.QueryPremiumSamplesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryPremiumSamplesRequest, ...grpc.CallOption) *types.QueryPremiumSamplesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryPremiumSamplesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryPremiumSamplesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PremiumVotes provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) PremiumVotes(ctx context.Context, in *types.QueryPremiumVotesRequest, opts ...grpc.CallOption) (*types.QueryPremiumVotesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PremiumVotes")
	}

	var r0 *types.QueryPremiumVotesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryPremiumVotesRequest, ...grpc.CallOption) (*types.QueryPremiumVotesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.QueryPremiumVotesRequest, ...grpc.CallOption) *types.QueryPremiumVotesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.QueryPremiumVotesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.QueryPremiumVotesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PreviousBlockInfo provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) PreviousBlockInfo(ctx context.Context, in *blocktimetypes.QueryPreviousBlockInfoRequest, opts ...grpc.CallOption) (*blocktimetypes.QueryPreviousBlockInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PreviousBlockInfo")
	}

	var r0 *blocktimetypes.QueryPreviousBlockInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *blocktimetypes.QueryPreviousBlockInfoRequest, ...grpc.CallOption) (*blocktimetypes.QueryPreviousBlockInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *blocktimetypes.QueryPreviousBlockInfoRequest, ...grpc.CallOption) *blocktimetypes.QueryPreviousBlockInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blocktimetypes.QueryPreviousBlockInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *blocktimetypes.QueryPreviousBlockInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamOrderbookUpdates provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) StreamOrderbookUpdates(ctx context.Context, in *clobtypes.StreamOrderbookUpdatesRequest, opts ...grpc.CallOption) (clobtypes.Query_StreamOrderbookUpdatesClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StreamOrderbookUpdates")
	}

	var r0 clobtypes.Query_StreamOrderbookUpdatesClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.StreamOrderbookUpdatesRequest, ...grpc.CallOption) (clobtypes.Query_StreamOrderbookUpdatesClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *clobtypes.StreamOrderbookUpdatesRequest, ...grpc.CallOption) clobtypes.Query_StreamOrderbookUpdatesClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(clobtypes.Query_StreamOrderbookUpdatesClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *clobtypes.StreamOrderbookUpdatesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Subaccount provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) Subaccount(ctx context.Context, in *subaccountstypes.QueryGetSubaccountRequest, opts ...grpc.CallOption) (*subaccountstypes.QuerySubaccountResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Subaccount")
	}

	var r0 *subaccountstypes.QuerySubaccountResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryGetSubaccountRequest, ...grpc.CallOption) (*subaccountstypes.QuerySubaccountResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryGetSubaccountRequest, ...grpc.CallOption) *subaccountstypes.QuerySubaccountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*subaccountstypes.QuerySubaccountResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *subaccountstypes.QueryGetSubaccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubaccountAll provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) SubaccountAll(ctx context.Context, in *subaccountstypes.QueryAllSubaccountRequest, opts ...grpc.CallOption) (*subaccountstypes.QuerySubaccountAllResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubaccountAll")
	}

	var r0 *subaccountstypes.QuerySubaccountAllResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryAllSubaccountRequest, ...grpc.CallOption) (*subaccountstypes.QuerySubaccountAllResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *subaccountstypes.QueryAllSubaccountRequest, ...grpc.CallOption) *subaccountstypes.QuerySubaccountAllResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*subaccountstypes.QuerySubaccountAllResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *subaccountstypes.QueryAllSubaccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLastConfirmedWithdrawId provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) UpdateLastConfirmedWithdrawId(ctx context.Context, in *api.UpdateLastConfirmedWithdrawIdRequest, opts ...grpc.CallOption) (*api.UpdateLastConfirmedWithdrawIdResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLastConfirmedWithdrawId")
	}

	var r0 *api.UpdateLastConfirmedWithdrawIdResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.UpdateLastConfirmedWithdrawIdRequest, ...grpc.CallOption) (*api.UpdateLastConfirmedWithdrawIdResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.UpdateLastConfirmedWithdrawIdRequest, ...grpc.CallOption) *api.UpdateLastConfirmedWithdrawIdResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UpdateLastConfirmedWithdrawIdResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.UpdateLastConfirmedWithdrawIdRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMarketPrices provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) UpdateMarketPrices(ctx context.Context, in *pricefeedapi.UpdateMarketPricesRequest, opts ...grpc.CallOption) (*pricefeedapi.UpdateMarketPricesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMarketPrices")
	}

	var r0 *pricefeedapi.UpdateMarketPricesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *pricefeedapi.UpdateMarketPricesRequest, ...grpc.CallOption) (*pricefeedapi.UpdateMarketPricesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *pricefeedapi.UpdateMarketPricesRequest, ...grpc.CallOption) *pricefeedapi.UpdateMarketPricesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pricefeedapi.UpdateMarketPricesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *pricefeedapi.UpdateMarketPricesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSubaccountsListForDeleveragingDaemon provides a mock function with given fields: ctx, in, opts
func (_m *QueryClient) UpdateSubaccountsListForDeleveragingDaemon(ctx context.Context, in *deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonRequest, opts ...grpc.CallOption) (*deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubaccountsListForDeleveragingDaemon")
	}

	var r0 *deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonRequest, ...grpc.CallOption) (*deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonRequest, ...grpc.CallOption) *deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *deleveragingapi.UpdateSubaccountsListForDeleveragingDaemonRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewQueryClient creates a new instance of QueryClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewQueryClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *QueryClient {
	mock := &QueryClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
